{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/svelte/store/index.mjs","../../../common/link-pick.js","../../src/Comment.svelte","../../src/ThingFull.svelte","../../src/Thing.svelte","../../node_modules/grid-of-things/src/ThingGrid.svelte","../../node_modules/svelte-float-window/src/w_resize.svelte","../../node_modules/svelte-float-window/src/FloatWindow.svelte","../../../common/data-utils.js","../../../common/display-utils.js","../../../common/Selections.svelte","../../../common/search_box.js","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.4' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","\nimport { writable } from 'svelte/store';\n\n//\nwindow._link_picker_list = {}\n\nclass LinkPicker {\n    //\n    constructor() {\n        this.picked = window._link_picker_list\n    }\n    //\n    add_entry(entry_id) {\n        if ( this.picked[entry_id] === undefined ) {\n            this.picked[entry_id] = true\n        }\n    }\n    //\n    remove_entry(entry_id) {\n        if ( this.picked[entry_id] !== undefined ) {\n            delete this.picked[entry_id]\n        }\n    }\n    //\n    is_picked(entry_id) {\n        return (this.picked[entry_id] !== undefined)\n    }\n    //\n    toggle_pick(entry_id) {\n        if ( this.is_picked(entry_id) ) {\n            this.remove_entry(entry_id)\n        } else {\n            this.add_entry(entry_id)\n        }\n    }\n    //\n    map_picks(entry_list) {\n        for ( let obj of entry_list ) {\n            if ( this.is_picked(obj.entry) ) {\n                this.picked[obj.entry] = obj\n            }\n        }\n    }\n    //\n    get_pick_values() {\n        let v_list = []\n        for ( let ky in this.picked ) {\n            v_list.push(this.picked[ky])\n        }\n        return v_list\n    }\n} \n\n\nfunction createPickerStats() {\n\tconst { subscribe, set, update } = writable(0);\n\n\treturn {\n\t\tsubscribe,\n\t\tincrement: () => update(n => n + 1),\n\t\tdecrement: () => update(n => n - 1),\n\t\treset: () => set(0)\n\t};\n}\n\nexport const picker = createPickerStats();\nexport const link_picker = new LinkPicker();","<script>\n\n\t// `current` is updated whenever the prop value changes...\n\texport let dates;\n\texport let entry;\n\texport let title;\n\texport let txt_full;\n\n\tlet truncated\n\t$: truncated = (txt_full !== undefined) ? txt_full.substr(0,250) + \"&#8230;\" : \"search\"\n\n\n\tfunction convert_date(secsdate) {\n\t\tif ( secsdate === 'never' ) {\n\t\t\treturn 'never';\n\t\t} else {\n\t\t\tlet idate = parseInt(secsdate)\n\t\t\tlet dformatted = (new Date(idate)).toLocaleDateString('en-US')\n\t\t\treturn (dformatted)\n\t\t}\n\t}\n\n\tlet updated_when\n\tlet created_when\n\n\t$: updated_when = dates ? convert_date(dates.updated) : \"\"\n\t$: created_when = dates ? convert_date(dates.created) : \"\"\n\n\tlet short_title\n\t$: short_title = title ? title.substr(0,16) + '...'  : \"...\"\n\n</script>\n\n<div class=\"blg-el-wrapper\" >\n\t<span style=\"color: darkbrown\">{entry}</span>\n\t<span style=\"background-color: yellowgreen\">{created_when}</span>\n\t<span style=\"background-color: lightblue\">{updated_when}</span>\n\t<h4 class=\"blg-item-title\" style=\"background-color: inherit;\">{short_title}</h4>\n\t<div class=\"teaser\">\n\t\t{@html truncated}\n\t</div>\t\n</div>\n\n\n<style>\n\n\t.blg-el-wrapper {\n\t\toverflow-y: hidden;\n\t\theight:inherit;\n\t}\n\n\tspan {\n\t\tdisplay: inline-block;\n\t\tpadding: 0.2em 0.5em;\n\t\tmargin: 0 0.2em 0.2em 0;\n\t\ttext-align: center;\n\t\tborder-radius: 0.2em;\n\t\tcolor: white;\n\t}\n\n\t.blg-item-title {\n\t\tcolor:black;\n\t\tdisplay: unset;\n\t\tborder-bottom: 1px darkslateblue solid;\n\t}\n\n\t.teaser {\n\t\tmargin-top: 3px;\n\t\tborder-top: 1px solid black;\n\t\tfont-size: 70%;\n\t\tcolor:rgba(129, 129, 129);\n\t\tbackground-color:rgb(250, 248, 248);\n\t\tmax-height: 60px;\n\t\toverflow-y: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t@media (max-width: 1200px) {\n\t\t.teaser {\n\t\t\tmax-height: 40px;\n\t\t}\n\t}\n\n\t@media (max-width: 1000px) {\n\t\t.teaser {\n\t\t\tmax-height: 30px;\n\t\t}\n\t}\n\n\t@media (max-width: 900px) {\n\t\t.teaser {\n\t\t\tmax-height: 24px;\n\t\t}\n\t}\n\n\t@media (max-width: 700px) {\n\t\t.teaser {\n\t\t\tmax-height: 20px;\n\t\t}\n\t}\n\n\t@media (max-width: 600px) { \n\t\t.teaser {\n\t\t\tmax-height: 40px;\n\t\t}\n\t}\n</style>","<script>\n\n\timport {link_picker,picker} from \"../../common/link-pick.js\"\n\timport Comment from './Comment.svelte';\n\n\t// ref ... https://gist.github.com/akirattii/9165836\n\n\t// `current` is updated whenever the prop value changes...\n\texport let color;\n\texport let entry;\n\texport let title;\n\texport let dates;\n\texport let subject;\n\texport let keys;\n\texport let txt_full;\n\texport let comments;\n\n\t$: key_str = keys.join(', ')\n\n\tfunction convert_date(secsdate) {\n\t\tif ( secsdate === 'never' ) {\n\t\t\treturn 'never';\n\t\t} else {\n\t\t\tlet idate = parseInt(secsdate)\n\t\t\tlet dformatted = (new Date(idate)).toLocaleDateString('en-US')\n\t\t\treturn (dformatted)\n\t\t}\n\t}\n\n\tlet have_comments = false\n\n\n\tlet picked_this = false\n\t$: picked_this = link_picker.is_picked(entry)\n\n\tlet updated_when\n\tlet created_when\n\n\t$: updated_when = convert_date(dates.updated)\n\t$: created_when = convert_date(dates.created)\n\n\tlet going_session = false\n\n\t$: if ( comments !== undefined ) {\n\t\tif ( typeof window.retrieve_session === \"function\" ) {\n\t\t\tgoing_session = window.retrieve_session()\n\t\t\tif ( going_session ) {\n\t\t\t\thave_comments = Array.isArray(comments) && (comments.length !== 0)\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tfunction present_comment_editing() {\n\t\tif ( going_session && (typeof window.launch_comment_editor === \"function\") ) {\n\t\t\twindow.launch_comment_editor(going_session,entry)\n\t\t}\n\t}\n\n\tfunction toggle_pick(ev) {\n\t\tlink_picker.toggle_pick(entry)\n\t\tif ( picked_this ) {\n\t\t\tpicker.increment()\n\t\t} else {\n\t\t\tpicker.decrement()\n\t\t}\n\t}\n\n\tlet count_value;\n\tconst unsubscribe = picker.subscribe(value => {\n\t\tcount_value = value;\n\t\tpicked_this = link_picker.is_picked(entry)\n\t});\n\n</script>\n \n<div class=\"blg-el-wrapper-full\">\n\t<div style=\"padding:6px;\" >\n\t\t<span style=\"background-color: {color}\">{entry}</span> <input type=\"checkbox\" bind:checked={picked_this} on:click={toggle_pick} />\n\t\t<span style=\"background-color: yellowgreen\">{created_when}</span>\n\t\t<span style=\"background-color: lightblue\">{updated_when}</span>\n\t\t{#if going_session } \n\t\t<button on:click={present_comment_editing}>add comment</button>\n\t\t{/if}\n\t\t<h4 class=\"blg-item-title\" style=\"background-color: inherit;\">{title}</h4>\n\t\t<h6>{key_str}</h6>\n\t\t<div>\n\t\t\t<span style=\"background-color:navy\">subject</span>&nbsp;&nbsp;<h5 class=\"blg-item-subject\" >{subject}</h5>\n\t\t</div>\n\t</div>\n\t<div id=\"blg-window-full-text\"  class=\"full-display\" >\n\t\t{@html txt_full}\n\t</div>\n\t<div class=\"comment-list-block\" >\n\t\t{#if have_comments }\n\t\t\t{#each comments as comment }\n\t\t\t\t<ul class=\"comment-list\">\n\t\t\t\t\t<li class=\"comment-list-entry\">\n\t\t\t\t\t\t<Comment {...comment}  />\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t{/each}\n\t\t{/if}\n\t</div>\n</div>\n\n<style>\n\n\t.blg-el-wrapper-full {\n\t\toverflow-y: hidden;\n\t\theight:inherit;\n\t}\n\tspan {\n\t\tdisplay: inline-block;\n\t\tpadding: 0.2em 0.5em;\n\t\tmargin: 0 0.2em 0.2em 0;\n\t\ttext-align: center;\n\t\tborder-radius: 0.2em;\n\t\tcolor: white;\n\t}\n\n\t.blg-item-title {\n\t\tcolor:black;\n\t\tdisplay: unset;\n\t\tborder-bottom: 1px darkslateblue solid;\n\t}\n\n\t.blg-item-subject {\n\t\tcolor:black;\n\t\tdisplay: unset;\n\t}\n\n\n\t.full-display {\n\t\tbackground-color: rgba(255, 255, 255, 0.9);\n\t\tcolor: rgb(73, 1, 1);\n\t\tborder-top: solid 2px rgb(88, 4, 88);\n\t\tpadding: 6px 4px 6px 4px;\n\t\toverflow-y: scroll;\n\t\theight: 100px;\n\t\tborder-bottom: solid 1px rgb(88, 4, 88);\n\t}\n\n\th6 {\n\t\tbackground-color: rgb(245, 245, 245);\n\t\tborder: 1px black solid;\n\t\tborder-radius: 0.2em;\n\t\tpadding: 0.2em 0.5em;\n\t\tmargin: 0 0.2em 0.2em 0;\n\t\tcolor:black;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t\twhite-space: nowrap;\n\t\twidth: 200px;\n\t}\n</style>","<script>\n\n\timport {link_picker,picker} from \"../../common/link-pick.js\"\n\n\t// `current` is updated whenever the prop value changes...\n\texport let abstract;\n\texport let color;\n\texport let dates;\n\texport let entry;\n\texport let id;\n\texport let keys;\n\texport let media;\n\texport let score;\n\texport let subject;\n\texport let title;\n\texport let txt_full;\n\n\tlet truncated\n\t$: truncated = (txt_full !== undefined) ? txt_full.substr(0,250) + \"&#8230;\" : \"search\"\n\n\t$: key_str = keys ? keys.join(', ') : \"\"\n\n\tlet score_rounded\n\n\t$: score_rounded = score ? score.toFixed(3) : 0;\n\n\tlet picked_this = false\n\t$: picked_this = link_picker.is_picked(entry)\n\n\n\tfunction convert_date(secsdate) {\n\t\tif ( secsdate === 'never' ) {\n\t\t\treturn 'never';\n\t\t} else {\n\t\t\tlet idate = parseInt(secsdate)\n\t\t\tlet dformatted = (new Date(idate)).toLocaleDateString('en-US')\n\t\t\treturn (dformatted)\n\t\t}\n\t}\n\n\tlet updated_when\n\tlet created_when\n\n\t$: updated_when = dates ? convert_date(dates.updated) : \"\"\n\t$: created_when = dates ? convert_date(dates.created) : \"\"\n\n\tlet short_title\n\t$: short_title = title ? title.substr(0,16) + '...'  : \"...\"\n\n\tlet short_subject\n\t$: short_subject = subject ? subject.substr(0,32) + '...' : \"...\"\n\n\tfunction toggle_pick(ev) {\n\t\tev.stopPropagation ()\n\t\tlink_picker.toggle_pick(entry)\n\t\tif ( picked_this ) {\n\t\t\tpicker.increment()\n\t\t} else {\n\t\t\tpicker.decrement()\n\t\t}\n\t}\n\n\tlet count_value;\n\tconst unsubscribe = picker.subscribe(value => {\n\t\tcount_value = value;\n\t\tpicked_this = link_picker.is_picked(entry)\n\t});\n\n</script>\n\n{#if dates && (dates.created != 'never') }\n<div class=\"blg-el-wrapper\" >\n\t\n\t<input type=\"checkbox\" bind:checked={picked_this} on:click={toggle_pick} />\n\t\n\t<span style=\"color: darkbrown\">{entry}</span>\n\t<span style=\"background-color: yellowgreen\">{created_when}</span>\n\t<span style=\"background-color: lightblue\">{updated_when}</span>\n\t<h4 class=\"blg-item-title\" style=\"background-color: inherit;\">{short_title}</h4>\n\t<h6>{key_str}</h6>\n\t<div>\n\t<span class=\"thng-score\">{score_rounded}</span><span style=\"background-color:navy\">subject</span>&nbsp;&nbsp;<h5 class=\"blg-item-subject\" >{short_subject}</h5>\n\t</div>\n\t<div class=\"teaser\">\n\t\t{@html truncated}\n\t</div>\t\n</div>\n\n{:else}\n<div class=\"blg-el-wrapper\">\n\t<h4 class=\"blg-item-title\" style=\"background-color: lightgrey;color:darkgrey\">End of Content</h4>\n</div>\n{/if}\n<style>\n\n\t.blg-el-wrapper {\n\t\toverflow-y: hidden;\n\t\theight:inherit;\n\t}\n\n\tspan {\n\t\tdisplay: inline-block;\n\t\tpadding: 0.2em 0.5em;\n\t\tmargin: 0 0.2em 0.2em 0;\n\t\ttext-align: center;\n\t\tborder-radius: 0.2em;\n\t\tcolor: white;\n\t}\n\n\t.blg-item-title {\n\t\tcolor:black;\n\t\tdisplay: unset;\n\t\tborder-bottom: 1px darkslateblue solid;\n\t}\n\n\t.blg-item-subject {\n\t\tcolor:black;\n\t\tdisplay: unset;\n\t}\n\n\t.thng-score {\n\t\tbackground-color: rgb(247, 247, 225);\n\t\tcolor: rgb(4, 4, 104);\n\t\tfont-size: 0.60em;\n\t\tfont-weight: bold;\n\t\tborder: solid 1px rgb(233, 233, 164);\n\t}\n\n\t.teaser {\n\t\tmargin-top: 3px;\n\t\tborder-top: 1px solid black;\n\t\tfont-size: 70%;\n\t\tcolor:rgba(129, 129, 129);\n\t\tbackground-color:rgb(250, 248, 248);\n\t\tmax-height: 60px;\n\t\toverflow-y: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\th6 {\n\t\tbackground-color: rgb(245, 245, 245);\n\t\tborder: 1px black solid;\n\t\tborder-radius: 0.2em;\n\t\tpadding: 0.2em 0.5em;\n\t\tmargin: 0 0.2em 0.2em 0;\n\t\tcolor:black;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t\twhite-space: nowrap;\n\t\twidth: 200px;\n\t}\n\n\t@media (max-width: 1200px) {\n\t\t.teaser {\n\t\t\tmax-height: 40px;\n\t\t}\n\t}\n\n\t@media (max-width: 1000px) {\n\t\t.teaser {\n\t\t\tmax-height: 30px;\n\t\t}\n\t}\n\n\t@media (max-width: 900px) {\n\t\t.teaser {\n\t\t\tmax-height: 24px;\n\t\t}\n\t}\n\n\t@media (max-width: 700px) {\n\t\t.teaser {\n\t\t\tmax-height: 20px;\n\t\t}\n\t}\n\n\t@media (max-width: 600px) { \n\t\t.teaser {\n\t\t\tmax-height: 40px;\n\t\t}\n\t}\n</style>","<script>\n\t// `current` is updated whenever the prop value changes...\n\texport let things;\n\texport let thing_component\n\timport { createEventDispatcher } from 'svelte';\n\n\tconst dispatch = createEventDispatcher();\n\n\tfunction do_display(event) {\n\t\tlet tid = event.currentTarget.id\n\t\tdispatch('message', {\n\t\t\ttype: 'click',\n\t\t\ttext: ('click ' + tid)\n\t\t});\n\t}\n\n\tfunction show_titles(event) {\n\t\tlet tid = event.currentTarget.id\n\t\tdispatch('message', {\n\t\t\ttype: 'over',\n\t\t\ttext: ('over ' + tid)\n\t\t});\n\t}\n\n\tlet grid_container_class = \"grid-container\"\n\tlet element_poster_class = \"element-poster\"\n\n</script>\n\n<div class={grid_container_class} >\n\t{#each things as thing (thing.id)}\n\t\t<div id=\"xy_{thing.id}\" class={element_poster_class} on:click={do_display} on:mouseover=\"{show_titles}\">\n\t\t\t<svelte:component this={thing_component} {...thing} />\n\t\t</div>\n\t{/each}\n</div>\n\n<style>\n\t.grid-container {\n\t\tdisplay: grid;\n\t\tgrid-column-gap: 25px;\n\t\tgrid-row-gap: 10px;\n\t\tgrid-template-columns: auto auto auto;\n\t\tbackground-color: rgb(250, 250, 242);\n\t\tpadding: 10px;\n\t}\n\t.element-poster {\n\t\tpadding: 4px;\n\t\tborder: solid 1px darkgrey;\n\t\tbackground-color: white;\n\t\theight: 170px;\n\t\tbox-shadow: 5px 7px #888888;\n\t\tcursor:pointer;\n\t}\n\n\t@media (min-width: 1500px) { \n\t\t.grid-container {\n\t\t\tdisplay: grid;\n\t\t\tgrid-column-gap: 25px;\n\t\t\tgrid-row-gap: 10px;\n\t\t\tgrid-template-columns: auto auto auto auto;\n\t\t\tbackground-color:  rgb(250, 250, 242);\n\t\t\tpadding: 10px;\n\t\t}\n\t}\n\n\t@media (max-width: 900px) { \n\t\t.grid-container {\n\t\t\tdisplay: grid;\n\t\t\tgrid-column-gap: 25px;\n\t\t\tgrid-row-gap: 10px;\n\t\t\tgrid-template-columns: auto auto;\n\t\t\tbackground-color: rgb(250, 250, 242);\n\t\t\tpadding: 10px;\n\t\t}\n\t}\n\n\t@media (max-width: 600px) { \n\t\t.grid-container {\n\t\t\tdisplay: grid;\n\t\t\tgrid-column-gap: 25px;\n\t\t\tgrid-row-gap: 10px;\n\t\t\tgrid-template-columns: auto;\n\t\t\tbackground-color: rgb(250, 250, 242);\n\t\t\tpadding: 10px;\n\t\t}\n\t}\n\n</style>\n","<script>\n\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\n\nlet offset = { x: 0, y: 0 };\n\nfunction start_drag(e) {\n    let mover = e.target\n    if ( mover ) {\n        offset.x = e.pageX;;\n        offset.y = e.pageY;\n        window.addEventListener('mousemove', dragging, true);\n        window.addEventListener('mouseup', stop_drag, true);\n    }\n}\n\nfunction stop_drag(e) {\n    window.removeEventListener('mousemove', dragging, true);\n    window.removeEventListener('mouseup', stop_drag, true);\n    dispatch('message', {\n        \"cmd\" : \"stop\"\n    });\n}\n\n\nfunction dragging(e) {\n    let mover = e.target\n    if ( mover === undefined ) return\n\n    const width_delta = (e.pageX - offset.x);\n    const height_delta = (e.pageY - offset.y)\n    dispatch('message', {\n        \"cmd\" : \"drag\",\n        \"w_delta\": width_delta,\n        \"h_delta\": height_delta\n    });\n\n}\n\n\n\n// https://medium.com/the-z/making-a-resizable-div-in-js-is-not-easy-as-you-think-bda19a1bc53d\n\n</script>\n    <div class=\"drag-container\" on:mousedown={start_drag}  on:mouseup={stop_drag} >\n        <slot></slot>\n    </div>    \n\n<style>\n\n    .drag-container {\n        width: 25px;\n        height: 25px;\n        text-align: center;\n        vertical-align: middle;\n        border-radius: 50%; /*magic to turn square into circle*/\n        background: white;\n        border: 3px solid #4286f4;\n        box-sizing: border-box;\n        position:absolute;\n        right: -5px;\n        bottom: -5px;\n        cursor: nwse-resize;\n    }\n\n\n</style>","<script>\n\n\timport Resizer from './w_resize.svelte'\n\timport { onMount } from 'svelte';\n\n\texport let title;\n\texport let scale_size_array;\n\texport let index = 0;\n\n\tvar SCROLL_WIDTH = 24;\n\tvar Z_BOTTOM = 500\n\tconst minimum_size = 300;\n\t// \n\t//-- let the popup make draggable & movable.\n\tlet offset = { x: 0, y: 0 };\n\n\tlet original_width = 0;\n\tlet original_height = 0;\n\tlet original_x = 0;\n\tlet original_y = 0;\n\n\n\tfunction originals(popup) {\n\t\tif ( popup ) {\n\t\t\toriginal_width = parseFloat(getComputedStyle(popup, null).getPropertyValue('width').replace('px', ''));\n\t\t\toriginal_height = parseFloat(getComputedStyle(popup, null).getPropertyValue('height').replace('px', ''));\n\t\t\toriginal_x = popup.getBoundingClientRect().left;\n\t\t\toriginal_y = popup.getBoundingClientRect().top;\n\t\t}\n\t}\n\n\n\tlet scale_current_size = Object.assign({},scale_size_array)\n\n\tonMount(() => {\n\t\tlet z_index_buffer = window._fws_z_order\n\t\tif ( z_index_buffer === undefined ) {\n\t\t\twindow._fws_z_order = []\n\t\t\tz_index_buffer = window._fws_z_order\n\t\t}\n\t\tz_index_buffer.push(index)\n\n\t\t//\n\t\tvar popup = document.getElementById(`popup_${index}`);\n\t\tif ( popup === undefined ) return\n\t\tdo_resize(index)\n\t\t//\n\t\tvar popup_bar = document.getElementById(`popup_bar_${index}`);\n\t\t//\n\t\tpopup_bar.addEventListener('mousedown', mouseDown, false);\n\t\twindow.addEventListener('mouseup', mouseUp, false);\n\t\twindow.addEventListener('keydown',(e) => {\n\t\t\tif ( e.keyCode == 27 ) { // if ESC key pressed\n\t\t\t\tvar popup = document.getElementById(`popup_${index}`);\n\t\t\t\tif ( popup === undefined ) return\n\t\t\t\tpopup.style.display = \"none\";\n\t\t\t}\n\t\t})\n\n\t\twindow.addEventListener(\"resize\",(e) => {\n\t\t\tdo_resize(index)\n\t\t})\n\n\t\twindow.start_floating_window = (index) => {\n\t\t\tpopup_starter(index)\n\t\t}\n\n\t})\n\n\n\tfunction fix_z_order(idx) {\n\t\tlet z_index_buffer = window._fws_z_order\n\t\tif ( z_index_buffer !== undefined ) {\n\t\t\tif ( typeof idx === \"string\" ) idx = parseInt(idx)\n\t\t\tlet pos = z_index_buffer.indexOf(idx)\n\t\t\tif ( pos >=0 ) {\n\t\t\t\tz_index_buffer.splice(pos,1)\n\t\t\t\tz_index_buffer.push(idx)\n\t\t\t\tlet bottom_z = Z_BOTTOM\n\t\t\t\tfor ( let p_i of z_index_buffer ) {\n\t\t\t\t\tlet popupId = `popup_${p_i}`\n\t\t\t\t\tlet popup = document.getElementById(popupId);\n\t\t\t\t\tif ( popup ) {\n\t\t\t\t\t\tpopup.style.zIndex = bottom_z++\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handle_close(e) {\n\t\tlet closer = e.target.id\n\t\tif ( closer ) {\n\t\t\tlet idx = closer.replace('btn_close_','')\n\t\t\tlet popupId = `popup_${idx}`\n\t\t\tvar popup = document.getElementById(popupId);\n\t\t\tif ( popup === undefined ) return\n\t\t\tpopup.style.display = \"none\";\n\t\t}\n\t}\n\n\n\n\tfunction fix_height(ii,startup_delta) {\n\t\tlet txt_area = document.getElementById('blg-window-full-text');\n\t\tif ( txt_area ) {\n\t\t\t//\n\t\t\ttxt_area._blg_app_resized = true\n\t\t\t//\n\t\t\tlet r = txt_area.getBoundingClientRect();\n\t\t\t//\n\t\t\tvar popup = document.getElementById(`popup_${ii}`);\n\t\t\tif ( popup ) {\n\t\t\t\tlet rp = popup.getBoundingClientRect();\n\t\t\t\tlet h = Math.floor(rp.bottom - r.top) - startup_delta\n\t\t\t\ttxt_area.style.height = h + \"px\";\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction handle_size(event) {\n\t\tif ( event && event.detail ) {\n\t\t\tif ( event.detail.cmd == 'drag' ) {\n\t\t\t\tlet w_dlt = event.detail.w_delta\n\t\t\t\tlet h_dlt = event.detail.h_delta\n\t\t\t\t//\n\t\t\t\tconst width = original_width + w_dlt;\n\t\t\t\tconst height = original_height + h_dlt;\n\t\t\t\tvar popup = document.getElementById(`popup_${index}`);\n\t\t\t\tif ( popup ) {\n\t\t\t\t\tif (width > minimum_size) {\n\t\t\t\t\t\tpopup.style.width = width + 'px'\n\t\t\t\t\t}\n\t\t\t\t\tif (height > minimum_size) {\n\t\t\t\t\t\tpopup.style.height = height + 'px'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( event.detail.cmd == 'stop' ) {\n\t\t\t\tvar popup = document.getElementById(`popup_${index}`);\n\t\t\t\toriginals(popup)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction do_resize(ii) {\n\t\tvar popup = document.getElementById(`popup_${ii}`);\n\t\tif ( popup ) {\n\t\t\tpopup.style.width = (window.innerWidth*scale_current_size.w) - SCROLL_WIDTH + \"px\";\n\t\t\tpopup.style.height = (window.innerHeight*scale_current_size.h) - SCROLL_WIDTH + \"px\";\n\t\t\toriginals(popup)\n\t\t}\n\t}\n\n\tfunction popup_starter(ii) {\n\t\tvar popup = document.getElementById(`popup_${ii}`);\n\t\tif ( popup && (popup.style.display !== 'block') ) {\n\t\t\tpopup.style.top = \"4px\";\n\t\t\tpopup.style.left = \"4px\";\n\t\t\tpopup.style.width = (window.innerWidth*scale_current_size.w) - SCROLL_WIDTH + \"px\";\n\t\t\tpopup.style.height = (window.innerHeight*scale_current_size.h) - SCROLL_WIDTH + \"px\";\n\t\t\tpopup.style.display = \"block\";\n\t\t\tsetTimeout(() => { fix_height(ii,4); },40)\n\t\t}\n\t\tsetTimeout(() => { fix_height(ii,4); },20)\n\t}\n\n\tfunction mouseUp(e) {  // popupMove is temporarily assiged to just one subwindow\n\t\twindow.removeEventListener('mousemove', popupMove, true);\n\t}\n\n\tfunction mouseDown(e) {\n\t\tlet mover = e.target.id\n\t\tif ( mover ) {\n\t\t\tlet idx = mover.replace('popup_bar_','')\n\t\t\tlet popupId = `popup_${idx}`\n\t\t\tvar popup = document.getElementById(popupId);\n\t\t\tif ( !(popup) ) return\n\t\t\tfix_z_order(idx)\n\t\t\toffset.x = e.clientX - popup.offsetLeft;\n\t\t\toffset.y = e.clientY - popup.offsetTop;\n\t\t\twindow.addEventListener('mousemove', popupMove, true);\n\t\t}\n\t}\n\n\tfunction popupMove(e){\n\t\tvar popup = document.getElementById(`popup_${index}`);\n\t\tif ( popup === undefined ) return\n\t\tpopup.style.position = 'absolute';\n\t\tvar top = Math.max((e.clientY - offset.y),0);\n\t\tvar left = Math.max((e.clientX - offset.x),0);\n\t\tpopup.style.top = top + 'px';\n\t\tpopup.style.left = left + 'px';\n\t}\n\t//-- / let the popup make draggable & movable.\n\n</script>\n\n<div id=\"popup_{index}\"  class=\"popup\" >\n\t<div id=\"popup_bar_{index}\" class=\"popup_bar\" on:mousedown={mouseDown} on:mouseup={mouseUp} >\n\t  {title}\n\t  <span id=\"btn_close_{index}\" class=\"btn_close\" on:click={handle_close} >[X]</span>\n\t</div>\n\t<p style=\"font-size:0.75em;font-weight:bold;color:darkgreen;padding-left:4px\">Press ESC to close window.</p>\n\t\t<slot></slot>\n\t<Resizer on:message={handle_size} >&#9449;</Resizer>\n</div>\n\n<style>\n\n\t.popup {\n\t\tdisplay:none;\n\t\tbackground-color:rgb(255, 255, 255);\n\t\tposition:absolute;\n\t\ttop:0px;\n\t\tz-index:9999;\n\t\tbox-shadow: 6px 6px 5px #888888;\n\t\tborder-radius:6px;\n\t\tborder:1px solid #4f4f4f;\n\t\twidth: 40%\n\t}\n\n\t.popup_bar {\n\t\twidth:100%;\n\t\tbackground-color:#76d825;\n\t\tposition:relative;top:0;\n\t\tborder-radius:6px 6px 0 0;\n\t\ttext-align:center;\n\t\theight:24px;\n\t\tcursor:move\n\t}\n\n\t.btn_close {\n\t\tfloat:right;\n\t\tcursor:pointer;\n\t\tpadding-right:6px;\n\t}\n\n</style>","\nconst TESTING = false\n\n\nexport function clonify(obj) {\n    let o = JSON.parse(JSON.stringify(obj))\n    return o\n}\n\n\nlet thing_template = {\n    \"color\": 'grey',\n    \"title\" : \"no content\",\n    \"_tracking\" : false,\n    \"dates\" : {\n        \"created\" : \"never\",\n        \"updated\" : \"never\"\n    },\n    \"subject\" : \"\",\n    \"abstract\" : \"no content\",\n    \"keys\" : [  ],\n    \"media\" : {\n        \"_x_link_counter\" : \"nowhere\",\n        \"protocol\" : \"default\",\n        \"poster\" : \"test\",\n        \"source\" : \"test\"\n    },\n    \"components\" : {\n        \"graphic\" : [],\n        \"boxes\" : []\n    },\n    \"comments\" : [],\n    \"score\" : 1.0\n}\n\n\nexport function make_empty_thing(model_template,no_clone) {\n    if ( model_template !== undefined ) {\n        thing_template = model_template\n        app_empty_object = Object.assign({ \"id\" : 1, \"entry\" : -1 },thing_template)\n    } else {\n        model_template = thing_template\n    }\n    if ( no_clone ) {\n        return Object.assign({},app_empty_object)\n    }\n    return clonify(model_template)\n}\n\nlet app_empty_object = Object.assign({ \"id\" : 1, \"entry\" : -1 },thing_template)\n\n\n\nfunction padd_other_things(count,other_things) {\n    let n = count - other_things.length\n    while ( n > 0 ) {\n        other_things.push(false)\n        n--\n    }\n}\n\n\n\nexport function place_data(things,other_things,article_index,dstart) {\n    let l = things.length;\n    let lo = other_things.length;\n    //\n    let strt = (( dstart === undefined ) ? (article_index-1) : (dstart-1));\n    //\n    for ( let i = 0; i < l; i++ ) {\n        if ( (strt + i) < lo ) {\n            let oto = other_things[strt + i];\n            if ( oto !== false ) {\n                oto.id = i+1;\n                things[i] = oto;\n            } else {\n                let ceo = clonify(app_empty_object);\n                ceo.id = i+1;\n                things[i] = ceo;\n            }\n        } else {\n            let ceo = clonify(app_empty_object);\n            ceo.id = i+1;\n            things[i] = ceo;\n        }\n    }\n    return things\n}\n\n\nexport function merge_data(merger,things,other_things,article_index,dstart) {\n    let l = things.length;\n    let lo = other_things.length;\n    //\n    let strt = (( dstart === undefined ) ? (article_index-1) : (dstart-1));\n    //\n    for ( let i = 0; i < l; i++ ) {\n        if ( (strt + i) < lo ) {\n            let oto = other_things[strt + i];\n            if ( oto !== false ) {\n                oto.id = i+1;\n                things[i] = merger(things[i],oto);\n            } else {\n                let ceo = clonify(app_empty_object);\n                ceo.id = i+1;\n                things[i] = merger(things[i],ceo);\n            }\n        } else {\n            let ceo = clonify(app_empty_object);\n            ceo.id = i+1;\n            things[i] = merger(things[i],ceo);\n        }\n    }\n    return things\n}\n\n\nlet faux_data = () => { return []}\nif ( TESTING ) {\n    function test_produce_data() {\t\t// retun the same object with all its fields only changing ones tranported encoded\n        let usable_data = [\n            {\n                \"entry\" : \"\" + Math.floor(Math.random()*1000), \n                \"_tracking\" : \"100001\",\n                \"subject\" : \"test 1\", \"title\" : \"test1 title\", \"score\" : 2.3, \n                        \"txt_full\" : \"something to talk about...\", \"abstract\" : \"absctraction\", \"keys\" : [\"t1\", \"t2\"],\n                        \"dates\" : {\n                            \"created\" : Date.now(),\n                            \"updated\" : Date.now(),\n                        },\n                \"media\" : {\n                    \"protocol\" : \"default\",\n                    \"_tracking\" : \"100001\",\n                    \"_x_link_counter\" : \"nowhere\",\n                    \"protocol\" : \"default\",\n                    \"poster\" : \"test\",\n                    \"source\" : \"test\"\n                },\n                \"color\" : \"darkbrown\"\n            },\n            {\n                \"entry\" : \"\" + Math.floor(Math.random()*1000),\n                \"_tracking\" : \"100002\",\n                \"subject\" : \"test 2\", \"title\" : \"test2 title\", \"score\" : 2.2,\n                \"txt_full\" : \"two something to talk about...\", \"abstract\" : \"too absctraction\", \"keys\" : [\"t1\", \"t2\"],\n                        \"dates\" : {\n                            \"created\" : Date.now(),\n                            \"updated\" : Date.now(),\n                        },\n                \"media\" : {\n                    \"protocol\" : \"default\",\n                    \"_tracking\" : \"100002\",\n                    \"_x_link_counter\" : \"nowhere\",\n                    \"protocol\" : \"default\",\n                    \"poster\" : \"test\",\n                    \"source\" : \"test\"\n                },\n                \"color\" : \"blue\"\n            },\n            { \n                \"entry\" : \"\" + Math.floor(Math.random()*1000),\n                \"subject\" : \"test 3\", \"title\" : \"test3 title\", \"score\" : 2.1,\n                \"_tracking\" : \"100003\",\n                \"txt_full\" : \"three's something to talk about...\", \"abstract\" : \"triangle absctraction\", \"keys\" : [\"t1\", \"t2\"],\n                        \"dates\" : {\n                            \"created\" : Date.now(),\n                            \"updated\" : Date.now(),\n                        },\n                \"media\" : {\n                    \"protocol\" : \"default\",\n                    \"_tracking\" : \"100003\",\n                    \"_x_link_counter\" : \"nowhere\",\n                    \"protocol\" : \"default\",\n                    \"poster\" : \"test\",\n                    \"source\" : \"test\"\n                },\n                \"color\" : \"yellow\"\n            },\n            {\n                \"entry\" : \"\" + Math.floor(Math.random()*1000), \n                \"_tracking\" : \"100004\",\n                \"subject\" : \"test 4\", \"title\" : \"test4 title\", \"score\" : 2.0,\n                \"txt_full\" : \"fore's something to talk about...\", \"abstract\" : \"square absctraction\", \"keys\" : [\"t1\", \"t2\"],\n                        \"dates\" : {\n                            \"created\" : Date.now(),\n                            \"updated\" : Date.now(),\n                        },\n                \"media\" : {\n                    \"protocol\" : \"default\",\n                    \"_tracking\" : \"100004\",\n                    \"_x_link_counter\" : \"nowhere\",\n                    \"protocol\" : \"default\",\n                    \"poster\" : \"test\",\n                    \"source\" : \"test\"\n                },\n                \"color\" : \"red\"\n            }\n        ]\n\n\n        let exportable_data = usable_data.map(datum => {\n            datum.title = datum.title ? decodeURIComponent(datum.title) : \"no title\"\n            datum.abstract = datum.abstract ? decodeURIComponent(datum.abstract) : \"no abstract\"\n            if (  datum.keys && Array.isArray(datum.keys) ) {\n                datum.keys = datum.keys.map(key => {\n                    return(decodeURIComponent(key))\n                })                \n            }\n            return datum\n        })\n        return { \n            \"status\" : \"OK\",\n            \"count\" : 4,\n            \"data\" : exportable_data\n        }\n    }\n\n    faux_data = test_produce_data\n}\n\n\nexport async function link_server_fetch(url, post_params, postData) {\n    if ( TESTING ) {\n        return faux_data()\n    } else {\n        if ( typeof window.personalization === 'function' )\n            window.personalization(post_params)\n    }\n        return await postData(url, post_params)\n}\n\n\n//\nexport function unload_data(data) {\n    let usable_data = data.map(datum => {\n        datum.title = datum.title ? decodeURIComponent(datum.title) : \"no title\"\n        datum.abstract = datum.abstract ? decodeURIComponent(datum.abstract) : \"no abstract\"\n        if (  datum.keys && Array.isArray(datum.keys) ) {\n            datum.keys = datum.keys.map(key => {\n                return(decodeURIComponent(key))\n            })                \n        }\n        return datum\n    })\n    return usable_data\n}\n\n//\nexport function process_search_results(stindex,qstart,search_result,other_things,data_unloader) {\n    //\n    let article_index = 1\n    //\n    if ( search_result ) {\n        let data = search_result.data;\n        if ( data ) {\n            //\n            if ( data_unloader !== undefined ) {\n                data = data_unloader(data)\n            } else {\n                data = unload_data(data)\n            }\n            //\n            let lo = search_result.count;\n            if ( qstart === undefined ) {\t// used the search button\n                if ( lo > data.length ) {\n                    padd_other_things(lo,data)\n                }\n                return [1,lo,data]\n            } else {\n                //\n                if ( lo > other_things.length ) {\n                    padd_other_things(lo,other_things)\n                }\n                //\n                let n = data.length\n                for ( let i = 0; i < n; i++ ) {\n                    other_things[i + stindex] = data.shift()\n                }\n                // // \n            }\n            //\n            return [article_index,lo,other_things]\n        }\n    }\n    //\n    return [false,false,false]\n}\n\n\n\nexport function remove_duplicate_entries(ply2_ary) {\n    let deletes = []\n    let n = ply2_ary.length;\n    for (let i = 0; i < n; i++ ) {\n        let chk = ply2_ary[i]\n        let next_i = i\n        for ( let j = i+1; j < n; j++ ) {\n            let tst = ply2_ary[j]\n            if ( chk[0] === tst[0] ) {\n                if ( chk[1] === tst[1] ) {\n                    deletes.push(j)\n                    next_i++\n                }\n            }\n        }\n        i = next_i\n    }\n\n    while ( deletes.length ) {\n        let dj = deletes.pop()\n        if ( dj !== undefined ) {\n            ply2_ary.splice(dj,1)  \n        }\n    }\n    return ply2_ary\n}\n","\n\n\nexport function popup_size() {\n    let smallest_w = 200   // smallest and bigget willing to accomodate\n    let biggest_w = 3000\n\n    let smallest_h = 600\n    let biggest_h = 1000\n\n    // bounded window width\n    let w = Math.max(smallest_w,window.innerWidth)\n    w = Math.min(biggest_w,w)\n\n    // bounded window height\n    let h = Math.max(smallest_h,window.innerHeight)\n    h = Math.min(biggest_h,h)\n\n    if ( w > 560 ) {\n        let p_range\n        let P\n        //\tpercentage h range \n        let h_p_max = 0.80\n        let h_p_min = 0.60\n        p_range = h_p_max - h_p_min\n        P = (biggest_h - h)/(biggest_h - smallest_h)\n        //console.log(\"P h: \" + P)\n        let h_scale = P*(p_range) + h_p_min\n    \n        //\tpercentage w range \n        let w_p_max = 0.96\n        let w_p_min = 0.20\n        p_range = w_p_max - w_p_min\n        P = (biggest_w - w)/(biggest_w - smallest_w)\n        //console.log(\"P w: \" + P)\n        let w_scale = P*(p_range) + w_p_min\n    \n        // Setting the current height & width \n        // to the elements \n    \n        return { \"w\" : w_scale, \"h\" : h_scale }    \n    } else {\n        let p_range\n        let P\n        //\tpercentage h range \n        let h_p_max = 0.90\n        let h_p_min = 0.80\n        p_range = h_p_max - h_p_min\n        P = (biggest_h - h)/(biggest_h - smallest_h)\n        //console.log(\"P h: \" + P)\n        let h_scale = P*(p_range) + h_p_min\n    \n        //\tpercentage w range \n        let w_p_max = 1.0\n        let w_p_min = (w > 480) ? 0.80 : 0.95\n        p_range = w_p_max - w_p_min\n        P = (biggest_w - w)/(biggest_w - smallest_w)\n        //console.log(\"P w: \" + P)\n        let w_scale = P*(p_range) + w_p_min\n    \n        // Setting the current height & width \n        // to the elements \n    \n        return { \"w\" : w_scale, \"h\" : h_scale }        \n    }\n}\n","<script>\n\n\timport {link_picker,picker} from \"./link-pick.js\"\n\n\texport let link_picks;\n\n\tlet count_value;\n\tconst unsubscribe = picker.subscribe(value => {\n\t\tcount_value = value;\n\t\tlink_picks = link_picker.get_pick_values()\n\t});\n\n</script>\n \n<div class=\"blg-el-wrapper-full\">\n\t<ul>\n\t\t{#each link_picks as thing (thing.id)}\n\t\t<li id=\"xy_{thing.id}\" class=\"element-poster\">\n\t\t\t{thing.title}\n\t\t</li>\n\t\t{/each}\t\n\t</ul>\n</div>\n\n<style>\n\n\t.blg-el-wrapper-full {\n\t\toverflow-y: hidden;\n\t\theight:inherit;\n\t}\n\n</style>","\n\n\n// ----\nlet g_search_table = {}\nlet g_when_table = {}\nlet g_all_keys = []\n\nlet g_prune_timeout = null\n\nconst TIMEOUT_THRESHHOLD = 4*60*60\n\n// got this from somewhere\nfunction uuidv4() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }\n\n\nfunction gen_unique_id() {\n    let ky = uuidv4()\n    while ( g_all_keys.indexOf(ky) >= 0 ) ky = uuidv4()\n    return ky\n} \n\nfunction prune_old_keys() {\n    //\n    let deleters = []\n    let tcheck = Date.now()\n    for ( let ky in g_search_table ) {\n        let was_when = g_when_table[ky]\n        if ( (tcheck - was_when) > TIMEOUT_THRESHHOLD ) {\n            deleters.push(ky)\n        }\n    }\n    deleters.forEach((ky) => {\n        delete g_when_table[ky]\n        delete g_search_table[ky]\n    })\n\n    deleters = []  // push it along\n}\n\n\nexport function add_search(key) {\n    if ( g_all_keys.length >= 200 ) {\n        if ( g_prune_timeout === null ) {\n            g_prune_timeout = setTimeout(prune_old_keys,60000*10)\n        }\n    }\n    let uid = gen_unique_id()\n    g_search_table[key] = uid // writes over old seaches\n    g_when_table[key] = Date.now()\n    g_all_keys = Object.keys(g_search_table)\n    return(uid)\n}\n\n\nexport function get_search(key,add_if_new = false) {\n\n    if ( key in g_search_table ) {\n        return(g_search_table[key])\n    }\n    if ( add_if_new ) {\n        return(add_search(key))\n    }\n}","<script>\n\texport let name;\n\n\timport FullThing from './ThingFull.svelte';\n\timport Thing from './Thing.svelte'\n\timport ThingGrid from 'grid-of-things';\n\timport FloatWindow from 'svelte-float-window';\n\n\timport { process_search_results, place_data, clonify, make_empty_thing, link_server_fetch } from '../../common/data-utils.js'\n\timport { popup_size } from '../../common/display-utils.js'\n\timport Selections from '../../common/Selections.svelte'\n\timport {link_picker,picker} from \"../../common/link-pick.js\"\n\timport {get_search} from \"../../common/search_box.js\"\n\n\timport { onMount } from 'svelte';\n\n\tlet session = \"\"\n\tlet going_session = \"\"\n\n\tlet ucwid = \"\"\n\n\tconst appsearch = 'search'  //   search later translated to songsearch (nginx conf by url)\n\n\tlet qlist_ordering = [\n\t\t{ id: 1, text: `update_date` },\n\t\t{ id: 2, text: `score` },\n\t\t{ id: 3, text: `create_date` }\n\t];\n\n\n\tlet all_link_picks = []\n\n\tlet search_ordering = qlist_ordering[2];\n\tlet search_topic = 'any'\n\n\tlet g_max_title_chars = 20\n\t//\n\tlet current_roller_title = \"\"\n\tlet current_roller_subject = \"\"\n\n\tlet thing_template = make_empty_thing()\n\n\tlet current_thing = Object.assign({ \"id\" : 0, \"entry\" : 0 },thing_template)\n\tlet app_empty_object = Object.assign({ \"id\" : 1, \"entry\" : -1 },thing_template)\n\t//\n\t\n\tlet window_scale = { \"w\" : 0.4, \"h\" : 0.6 }\n\t//\n\twindow_scale = popup_size()\n\tlet all_window_scales = []\n\tall_window_scales.push(window_scale)\n\tall_window_scales.push(window_scale)\n\t//\n\tonMount(async () => {\n\t\twindow.app_page_gets_ccwid = (ccwid) => { ucwid = ccwid}\n\t\tsession = await window.retrieve_session()\n\t\twindow.addEventListener(\"resize\", (e) => {\n\t\t\t//\n\t\t\tlet scale = popup_size()\n\t\t\t//\n\t\t\twindow_scale.h = scale.h; \n\t\t\twindow_scale.w = scale.w;\n\t\t\t//\n\t\t})\n\t})\n\n\n\tfunction present_assest_editing() {\n\t\tif ( going_session && (typeof window.launch_comment_editor === \"function\") ) {\n\t\t\twindow.launch_asset_editor(going_session)\n\t\t}\n\t}\n\n\n\tfunction handleMessage(event) {\n\t\tlet key = \"xy_\"\n\t\tlet txt = event.detail.text;\n\t\tlet idx = txt.substr(txt.indexOf(key) + 3);\n\n\t\tlet etype = event.detail.type\n\t\tidx = parseInt(idx);\n\t\tidx--;\n\t\tif ( (idx !== undefined) && (idx >= 0) && (idx < things.length)) {\n\t\t\tlet athing = things[idx];\n\t\t\tif ( athing !== undefined ) {\n\t\t\t\tif ( etype === 'click' ) {\n\t\t\t\t\tcurrent_thing = athing;\n\t\t\t\t\tstart_floating_window(0);\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_roller_title = athing.title\n\t\t\t\t\tcurrent_roller_subject = athing.subject\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction clickEmptyElement(thing_counter) {\n\t\t let elem = clonify(app_empty_object)\n\t\t elem.id = thing_counter\n\t\t return elem\n\t}\n\t\n\n\t\n\tlet things = [\t\t\t\t// window\n\t\tapp_empty_object\n\t];\n\n\tlet other_things = [];\t\t// current data...\t\tloaded from server \n\n\tlet article_count = 1\n\tlet article_index = 1\n\n\tlet box_delta = 1;\t\t// how boxes to add when increasing the window\n\n\tfunction needs_data(start,end) {\n\t\tif ( other_things.length > 0 ) {\n\t\t\tfor ( let i = start; i < end; i++ ) {\n\t\t\t\tif ( other_things[i] === false ) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn(false)\n\t}\n\n\tfunction do_data_placement() {\n\t\tlet end = (article_index + things.length)\n\t\tlet start = article_index - 1\n\t\tif ( needs_data(start,end) ) {\n\t\t\tdata_fetcher(start,things.length)\n\t\t} else {\n\t\t\tplace_data(things,other_things,article_index)\n\t\t}\n\t}\n\n\n\tfunction handleClick_remove() {\n\t\tfor ( let i = 0; i < box_delta; i++ ) {\n\t\t\tlet p = things\n\t\t\tp.pop()\n\t\t\tthings = [...p];\n\t\t}\n\t}\n\t\n\t// ---- ---- ---- ---- ---- ---- ----\n\tasync function handleClick_add() {\n\t\tlet start = things.length\n\t\tfor ( let i = 0; i < box_delta; i++ ) {\n\t\t\tlet thing_counter = things.length\n\t\t\tthing_counter++\n\t\t\tlet additional = clickEmptyElement(thing_counter)\n\t\t\tthings = [...things, additional];\n\t\t}\n\t\t//\n\t\tlet end = things.length   /// start + box_delta\n\t\tif ( needs_data(start,end) ) {\n\t\t\tdata_fetcher(start,things.length)\n\t\t} else {\n\t\t\tthings = place_data(things,other_things,article_index)\n\t\t}\n\t}\n\n\n\t//\n\tfunction handle_index_changed() {\n\t\tdo_data_placement()\n\t\t\n\t}\n\tfunction handleClick_first() {\n\t\tarticle_index = 1\n\t\tdo_data_placement()\n\t}\n\n\tfunction handleClick_last() {\n\t\tarticle_index = article_count\n\t\tdo_data_placement()\n\t}\n\n\tfunction handle_keyDown(ev) {\n\t\tif(ev.charCode == 13){\n\t\t\tarticle_index = 1\n\t\t\tdata_fetcher()\n\t\t}\n\t}\n\n\tfunction handle_order_change(ev) {\n\t\tarticle_index = 1\n\t\tdata_fetcher()\n\t}\n\n\n\tfunction handleClick_fetch(ev) {\n\t\tarticle_index = 1\n\t\tdata_fetcher()\n\t}\n\n\tasync function data_fetcher(qstart,alt_length) {\n\t\tlet l = (alt_length === undefined) ? things.length : alt_length\n\t\tlet stindex = (qstart === undefined) ? (article_index - 1): qstart\n\t\tlet qry = encodeURIComponent(search_topic)\n\n\t\tqry += '|' + search_ordering.text\n\t\t//\n\t\t//console.log(search_ordering.text)\n\t\t//\n\t\tlet uid = get_search(qry,true)\n\t\t//\n\t\tstindex = Math.max(0,stindex)\n\t\tlet post_params = {\n\t\t\t\"uid\" : uid,\n\t\t\t\"query\" : qry,\n\t\t\t\"box_count\" : l,\n\t\t\t\"offset\" : stindex\n\t\t};\n\t\ttry {\n\t\t\t// /:uid/:query/:bcount/:offset\n\t\t\tlet data_stem = \"blog-search\"   // Switch nginx to the proxy path for the search server...\n\t\t\tlet rest = `${post_params.uid}/${post_params.query}/${post_params.box_count}/${post_params.offset}`\n\t\t\tlet srver = location.host\n\t\t\tlet prot = location.protocol\n\t\t\tlet sp = '//'\n\t\t\tlet search_result = await link_server_fetch(`${prot}${sp}${srver}/${data_stem}/${rest}`,post_params, postData)\n\n\t\t\tlet [a_i,lo,ot] = process_search_results(stindex,qstart,search_result,other_things)\n\t\t\tarticle_index = a_i\n\t\t\tarticle_count = lo\n\t\t\tother_things = ot\n\n\t\t\tif ( other_things !== false ) {\n\t\t\t\tthings = place_data(things,other_things,article_index)\n\t\t\t}\n\n\t\t} catch (e) {\n\t\t\talert(e.message)\n\t\t}\n\t}\n\n\n\tlet count_value;\n\tconst unsubscribe = picker.subscribe(value => {\n\t\tcount_value = value;\n\t\tlink_picker.map_picks(things)\n\t});\n\n\n\tfunction pop_up_selections(ev) {\n\t\tall_link_picks = link_picker.get_pick_values()\n\t\tstart_floating_window(1);\n\t}\n\t\n</script>\n\n\n\n<div>\n\n\t<div style=\"border: solid 2px navy;padding: 4px;background-color:#EFEFEF;\">\n\t\t<div class=\"blg-ctrl-panel\" style=\"display:inline-block;vertical-align:bottom;background-color:#EFFFFE\" >\n\t\t\t<span style=\"color:navy;font-weight:bold\">Boxes</span>\n\t\t\t<input type=number class=\"blg-ctl-number-field\" bind:value={box_delta} min=1 max=4>\n\n\t\t\t<button class=\"blg-ctl-button\" on:click={handleClick_remove}>\n\t\t\t\t-\n\t\t\t</button>\n\n\t\t\t<button class=\"blg-ctl-button\"  on:click={handleClick_add}>\n\t\t\t\t+\n\t\t\t</button>\n\t\t</div>\n\t\t<div class=\"blg-ctrl-panel\" style=\"display:inline-block;vertical-align:bottom;background-color:#EFEFFE\" >\n\t\t\t<button on:click={handleClick_fetch}>\n\t\t\t\tsearch\n\t\t\t</button>\n\t\t\t<div style=\"display:inline-block;\">\n\t\t\t&nbsp;<input type=text bind:value={search_topic} on:keypress={handle_keyDown} >\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"blg-ctrl-panel\" style=\"display:inline-block;background-color:#FFFFFA\" >\n\t\t\t\n\t\t\t<button class=\"blg-ctl-button\" on:click={handleClick_first}>&le;</button>\n\t\t\t<input class=\"blg-ctl-slider\" type=range bind:value={article_index} min=1 max={article_count} on:change={handle_index_changed} >\n\t\t\t<button class=\"blg-ctl-button\" on:click={handleClick_last}>&ge;</button>\n\t\t\t<input type=number class=\"blg-ctl-number-field\" bind:value={article_index} min=1 max={article_count} on:change={handle_index_changed} >\n\t\t\tof {article_count}\n\t\t</div>\n\t\t<div class=\"blg-ctrl-panel\" style=\"display:inline-block;background-color:#FFFFFA\" >\n\t\t\t<select bind:value={search_ordering} on:change=\"{handle_order_change}\">\n\t\t\t\t{#each qlist_ordering as ordering}\n\t\t\t\t\t<option value={ordering}>\n\t\t\t\t\t\t{ordering.text}\n\t\t\t\t\t</option>\n\t\t\t\t{/each}\n\t\t\t</select>\n\t\t</div>\n\t</div>\n\t<div style=\"border: solid 1px grey;padding: 4px;background-color:#F5F6EF;\">\n\t\t{#if going_session }\n\t\t<div class=\"sel-titles blg-ctl-button\" ><button on:click={present_assest_editing}>add entry</button></div>\n\t\t{/if}\n\t\t<div class=\"sel-titles\" >Title: {current_roller_title}</div><div class=\"sel-titles\">Subject: {current_roller_subject}</div>\n\t\t<div class=\"sel-titles\" style=\"width: 15%;\"><button on:click={pop_up_selections}>show selections</button></div>\n\t</div>\n  \n\t<div class=\"blg-grid-container\">\n\t\t<ThingGrid things={things} thing_component={Thing} on:message={handleMessage} />\n\t</div>\n\n\t\n</div>\n\n\n<FloatWindow title={current_thing.title.substr(0,g_max_title_chars) + '...'}  index={0} scale_size_array={all_window_scales[0]} >\n\t<FullThing {...current_thing} />\n</FloatWindow>\n\n\n<FloatWindow title=\"Selection List\"  index={1} scale_size_array={all_window_scales[1]} >\n\t<Selections link_picks={all_link_picks}  />\n</FloatWindow>\n\n\n<style>\n\n\tmain {\n\t\ttext-align: center;\n\t\tpadding: 1em;\n\t\tmax-width: 240px;\n\t\tmargin: 0 auto;\n\t}\n\n\t.blg-grid-container {\n\t\tborder-top : solid 2px green;\n\t\tpadding-top: 4px;\n\t\theight: calc(100vh - 240px);\n\t\toverflow-y:scroll;\n\t\tbackground-color: rgb(250, 250, 242);\n\t}\n\n\t.blg-ctl-button {\n\t\tmax-width: 20px;\n\t\tborder-radius: 6px;\n\t}\n\n\t.blg-ctl-slider {\n\t\theight: 35px;\n\t\tvertical-align: bottom;\n\t}\n\n\t.blg-ctl-number-field {\n\t\tmax-width: 60px\n\t}\n\n\t.blg-ctrl-panel {\n\t\tpadding:2px;\n\t\tpadding-left:6px;\n\t\tpadding-right:4px;\n\t\tmargin:0px;\n\t\tborder: none;\n\t}\n\n\th1 {\n\t\tcolor: #ff3e00;\n\t\ttext-transform: uppercase;\n\t\tfont-size: 4em;\n\t\tfont-weight: 100;\n\t}\n\n\t@media (min-width: 640px) {\n\t\tmain {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n\n\t.sel-titles {\n\t\tdisplay:inline-block;\n\t\twidth:35%;\n\t\tfont-weight:bold;\n\t\tcolor:black;\n\t\tfont-size:0.75em;\n\t\tmargin: 6px;\n\t}\n\n\n</style>\n","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.getElementById('app-main'),\n\tprops: {\n\t\tname: 'My Blog With Grid'\n\t}\n});\n\nexport default app;"],"names":["noop","assign","tar","src","k","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","slice","get_slot_changes","dirty","lets","undefined","merged","len","Math","max","length","i","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","p","get_all_dirty_from_scope","null_to_empty","value","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","to_number","set_data","wholeText","set_input_value","input","set_style","key","important","style","setProperty","select_option","select","option","__value","selected","selectedIndex","current_component","set_current_component","component","get_current_component","Error","onMount","$$","on_mount","push","createEventDispatcher","type","detail","callbacks","bubbles","e","createEvent","initCustomEvent","custom_event","call","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","update","pop","callback","has","add","clear","fragment","before_update","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","destroy_block","lookup","outro_and_destroy_block","update_keyed_each","old_blocks","get_key","dynamic","list","destroy","create_each_block","next","get_context","n","old_indexes","new_blocks","new_lookup","Map","deltas","child_ctx","get","set","abs","will_move","did_move","m","first","new_block","old_block","new_key","old_key","get_spread_update","levels","updates","to_null_out","accounted_for","get_spread_object","spread_props","create_component","mount_component","customElement","on_destroy","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","skip_bound","root","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","$destroy","this","$on","index","indexOf","splice","$set","$$props","obj","$$set","keys","subscriber_queue","window","_link_picker_list","picker","subscribe","start","stop","subscribers","new_value","run_queue","subscriber","invalidate","size","writable","increment","decrement","reset","createPickerStats","link_picker","constructor","picked","add_entry","entry_id","remove_entry","is_picked","toggle_pick","map_picks","entry_list","entry","get_pick_values","v_list","ky","convert_date","secsdate","idate","parseInt","Date","toLocaleDateString","truncated","updated_when","created_when","short_title","dates","title","txt_full","substr","updated","created","color","subject","comments","have_comments","picked_this","going_session","key_str","join","retrieve_session","isArray","launch_comment_editor","ev","score_rounded","short_subject","abstract","id","media","score","toFixed","stopPropagation","element_poster_class","grid_container_class","things","thing_component","dispatch","tid","currentTarget","offset","x","y","stop_drag","dragging","cmd","width_delta","pageX","height_delta","pageY","w_delta","h_delta","handle_close","SCROLL_WIDTH","closer","popupId","replace","popup","getElementById","display","fix_height","ii","startup_delta","txt_area","_blg_app_resized","getBoundingClientRect","rp","h","floor","bottom","top","height","scale_size_array","original_width","original_height","originals","parseFloat","getComputedStyle","getPropertyValue","left","scale_current_size","do_resize","width","innerWidth","w","innerHeight","mouseUp","popupMove","mouseDown","mover","idx","z_index_buffer","_fws_z_order","pos","bottom_z","p_i","zIndex","fix_z_order","clientX","offsetLeft","clientY","offsetTop","position","keyCode","start_floating_window","setTimeout","popup_starter","w_dlt","h_dlt","clonify","JSON","parse","stringify","thing_template","_tracking","_x_link_counter","protocol","poster","source","components","graphic","boxes","make_empty_thing","model_template","no_clone","app_empty_object","padd_other_things","count","other_things","place_data","article_index","dstart","lo","strt","oto","ceo","process_search_results","stindex","qstart","search_result","data_unloader","datum","decodeURIComponent","unload_data","shift","popup_size","biggest_w","biggest_h","min","p_range","P","h_p_min","h_scale","w_p_min","link_picks","g_search_table","g_when_table","g_all_keys","g_prune_timeout","uuidv4","random","toString","prune_old_keys","deleters","tcheck","now","add_search","uid","gen_unique_id","Thing","g_max_title_chars","qlist_ordering","all_link_picks","search_ordering","search_topic","current_roller_title","current_roller_subject","current_thing","window_scale","all_window_scales","clickEmptyElement","thing_counter","elem","app_page_gets_ccwid","ccwid","scale","article_count","box_delta","needs_data","end","do_data_placement","data_fetcher","alt_length","qry","encodeURIComponent","add_if_new","get_search","post_params","query","box_count","data_stem","srver","location","host","prot","sp","async","url","postData","personalization","link_server_fetch","a_i","ot","alert","message","txt","etype","athing","additional","charCode","selected_option","querySelector"],"mappings":"gCAAA,SAASA,KAET,SAASC,EAAOC,EAAKC,GAEjB,IAAK,MAAMC,KAAKD,EACZD,EAAIE,GAAKD,EAAIC,GACjB,OAAOF,EAUX,SAASG,EAAIC,GACT,OAAOA,IAEX,SAASC,IACL,OAAOC,OAAOC,OAAO,MAEzB,SAASC,EAAQC,GACbA,EAAIC,QAAQP,GAEhB,SAASQ,EAAYC,GACjB,MAAwB,mBAAVA,EAElB,SAASC,EAAeC,EAAGC,GACvB,OAAOD,GAAKA,EAAIC,GAAKA,EAAID,IAAMC,GAAOD,GAAkB,iBAANA,GAAgC,mBAANA,EAoChF,SAASE,EAAYC,EAAYC,EAAKC,EAASf,GAC3C,GAAIa,EAAY,CACZ,MAAMG,EAAWC,EAAiBJ,EAAYC,EAAKC,EAASf,GAC5D,OAAOa,EAAW,GAAGG,IAG7B,SAASC,EAAiBJ,EAAYC,EAAKC,EAASf,GAChD,OAAOa,EAAW,IAAMb,EAClBL,EAAOoB,EAAQD,IAAII,QAASL,EAAW,GAAGb,EAAGc,KAC7CC,EAAQD,IAElB,SAASK,EAAiBN,EAAYE,EAASK,EAAOpB,GAClD,GAAIa,EAAW,IAAMb,EAAI,CACrB,MAAMqB,EAAOR,EAAW,GAAGb,EAAGoB,IAC9B,QAAsBE,IAAlBP,EAAQK,MACR,OAAOC,EAEX,GAAoB,iBAATA,EAAmB,CAC1B,MAAME,EAAS,GACTC,EAAMC,KAAKC,IAAIX,EAAQK,MAAMO,OAAQN,EAAKM,QAChD,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAKI,GAAK,EAC1BL,EAAOK,GAAKb,EAAQK,MAAMQ,GAAKP,EAAKO,GAExC,OAAOL,EAEX,OAAOR,EAAQK,MAAQC,EAE3B,OAAON,EAAQK,MAEnB,SAASS,EAAiBC,EAAMC,EAAiBjB,EAAKC,EAASiB,EAAcC,GACzE,GAAID,EAAc,CACd,MAAME,EAAejB,EAAiBc,EAAiBjB,EAAKC,EAASkB,GACrEH,EAAKK,EAAED,EAAcF,IAO7B,SAASI,EAAyBrB,GAC9B,GAAIA,EAAQD,IAAIa,OAAS,GAAI,CACzB,MAAMP,EAAQ,GACRO,EAASZ,EAAQD,IAAIa,OAAS,GACpC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQC,IACxBR,EAAMQ,IAAM,EAEhB,OAAOR,EAEX,OAAQ,EAiCZ,SAASiB,EAAcC,GACnB,OAAgB,MAATA,EAAgB,GAAKA,EAgKhC,SAASC,EAAOC,EAAQC,GACpBD,EAAOE,YAAYD,GAoDvB,SAASE,EAAOH,EAAQC,EAAMG,GAC1BJ,EAAOK,aAAaJ,EAAMG,GAAU,MAUxC,SAASE,EAAOL,GACZA,EAAKM,WAAWC,YAAYP,GAEhC,SAASQ,EAAaC,EAAYC,GAC9B,IAAK,IAAIvB,EAAI,EAAGA,EAAIsB,EAAWvB,OAAQC,GAAK,EACpCsB,EAAWtB,IACXsB,EAAWtB,GAAGwB,EAAED,GAG5B,SAASE,EAAQC,GACb,OAAOC,SAASC,cAAcF,GAoBlC,SAASG,EAAKC,GACV,OAAOH,SAASI,eAAeD,GAEnC,SAASE,IACL,OAAOH,EAAK,KAEhB,SAASI,IACL,OAAOJ,EAAK,IAEhB,SAASK,EAAOrB,EAAMsB,EAAOC,EAASC,GAElC,OADAxB,EAAKyB,iBAAiBH,EAAOC,EAASC,GAC/B,IAAMxB,EAAK0B,oBAAoBJ,EAAOC,EAASC,GA8B1D,SAASG,EAAK3B,EAAM4B,EAAW/B,GACd,MAATA,EACAG,EAAK6B,gBAAgBD,GAChB5B,EAAK8B,aAAaF,KAAe/B,GACtCG,EAAK+B,aAAaH,EAAW/B,GAkDrC,SAASmC,EAAUnC,GACf,MAAiB,KAAVA,EAAe,MAAQA,EAkIlC,SAASoC,EAASjB,EAAMC,GACpBA,EAAO,GAAKA,EACRD,EAAKkB,YAAcjB,IACnBD,EAAKC,KAAOA,GAEpB,SAASkB,EAAgBC,EAAOvC,GAC5BuC,EAAMvC,MAAiB,MAATA,EAAgB,GAAKA,EAUvC,SAASwC,EAAUrC,EAAMsC,EAAKzC,EAAO0C,GACjCvC,EAAKwC,MAAMC,YAAYH,EAAKzC,EAAO0C,EAAY,YAAc,IAEjE,SAASG,EAAcC,EAAQ9C,GAC3B,IAAK,IAAIV,EAAI,EAAGA,EAAIwD,EAAOnB,QAAQtC,OAAQC,GAAK,EAAG,CAC/C,MAAMyD,EAASD,EAAOnB,QAAQrC,GAC9B,GAAIyD,EAAOC,UAAYhD,EAEnB,YADA+C,EAAOE,UAAW,GAI1BH,EAAOI,eAAiB,EAqR5B,IAAIC,EACJ,SAASC,EAAsBC,GAC3BF,EAAoBE,EAExB,SAASC,IACL,IAAKH,EACD,MAAM,IAAII,MAAM,oDACpB,OAAOJ,EAKX,SAASK,EAAQ9F,GACb4F,IAAwBG,GAAGC,SAASC,KAAKjG,GAQ7C,SAASkG,IACL,MAAMP,EAAYC,IAClB,MAAO,CAACO,EAAMC,KACV,MAAMC,EAAYV,EAAUI,GAAGM,UAAUF,GACzC,GAAIE,EAAW,CAGX,MAAMtC,EA1OlB,SAAsBoC,EAAMC,EAAQE,GAAU,GAC1C,MAAMC,EAAIhD,SAASiD,YAAY,eAE/B,OADAD,EAAEE,gBAAgBN,EAAMG,GAAS,EAAOF,GACjCG,EAuOeG,CAAaP,EAAMC,GACjCC,EAAUnF,QAAQZ,SAAQN,IACtBA,EAAG2G,KAAKhB,EAAW5B,QA4BnC,MAAM6C,EAAmB,GAEnBC,EAAoB,GACpBC,EAAmB,GACnBC,EAAkB,GAClBC,EAAmBC,QAAQC,UACjC,IAAIC,GAAmB,EAWvB,SAASC,EAAoBpH,GACzB8G,EAAiBb,KAAKjG,GAK1B,IAAIqH,GAAW,EACf,MAAMC,EAAiB,IAAIC,IAC3B,SAASC,IACL,IAAIH,EAAJ,CAEAA,GAAW,EACX,EAAG,CAGC,IAAK,IAAIzF,EAAI,EAAGA,EAAIgF,EAAiBjF,OAAQC,GAAK,EAAG,CACjD,MAAM+D,EAAYiB,EAAiBhF,GACnC8D,EAAsBC,GACtB8B,EAAO9B,EAAUI,IAIrB,IAFAL,EAAsB,MACtBkB,EAAiBjF,OAAS,EACnBkF,EAAkBlF,QACrBkF,EAAkBa,KAAlBb,GAIJ,IAAK,IAAIjF,EAAI,EAAGA,EAAIkF,EAAiBnF,OAAQC,GAAK,EAAG,CACjD,MAAM+F,EAAWb,EAAiBlF,GAC7B0F,EAAeM,IAAID,KAEpBL,EAAeO,IAAIF,GACnBA,KAGRb,EAAiBnF,OAAS,QACrBiF,EAAiBjF,QAC1B,KAAOoF,EAAgBpF,QACnBoF,EAAgBW,KAAhBX,GAEJI,GAAmB,EACnBE,GAAW,EACXC,EAAeQ,SAEnB,SAASL,EAAO1B,GACZ,GAAoB,OAAhBA,EAAGgC,SAAmB,CACtBhC,EAAG0B,SACHrH,EAAQ2F,EAAGiC,eACX,MAAM5G,EAAQ2E,EAAG3E,MACjB2E,EAAG3E,MAAQ,EAAE,GACb2E,EAAGgC,UAAYhC,EAAGgC,SAAS5F,EAAE4D,EAAGjF,IAAKM,GACrC2E,EAAGkC,aAAa3H,QAAQ8G,IAiBhC,MAAMc,EAAW,IAAIX,IACrB,IAAIY,EACJ,SAASC,IACLD,EAAS,CACLE,EAAG,EACHC,EAAG,GACHnG,EAAGgG,GAGX,SAASI,IACAJ,EAAOE,GACRjI,EAAQ+H,EAAOG,GAEnBH,EAASA,EAAOhG,EAEpB,SAASqG,EAAcC,EAAOC,GACtBD,GAASA,EAAM7G,IACfsG,EAASS,OAAOF,GAChBA,EAAM7G,EAAE8G,IAGhB,SAASE,EAAeH,EAAOC,EAAO5F,EAAQ6E,GAC1C,GAAIc,GAASA,EAAMI,EAAG,CAClB,GAAIX,EAASN,IAAIa,GACb,OACJP,EAASL,IAAIY,GACbN,EAAOG,EAAErC,MAAK,KACViC,EAASS,OAAOF,GACZd,IACI7E,GACA2F,EAAMrF,EAAE,GACZuE,QAGRc,EAAMI,EAAEH,IA6ThB,SAASI,EAAcL,EAAOM,GAC1BN,EAAMrF,EAAE,GACR2F,EAAOJ,OAAOF,EAAM1D,KAExB,SAASiE,EAAwBP,EAAOM,GACpCH,EAAeH,EAAO,EAAG,GAAG,KACxBM,EAAOJ,OAAOF,EAAM1D,QAW5B,SAASkE,EAAkBC,EAAY9H,EAAO+H,EAASC,EAAStI,EAAKuI,EAAMN,EAAQtG,EAAM6G,EAASC,EAAmBC,EAAMC,GACvH,IAAIZ,EAAIK,EAAWvH,OACf+H,EAAIL,EAAK1H,OACTC,EAAIiH,EACR,MAAMc,EAAc,GACpB,KAAO/H,KACH+H,EAAYT,EAAWtH,GAAGmD,KAAOnD,EACrC,MAAMgI,EAAa,GACbC,EAAa,IAAIC,IACjBC,EAAS,IAAID,IAEnB,IADAlI,EAAI8H,EACG9H,KAAK,CACR,MAAMoI,EAAYP,EAAY3I,EAAKuI,EAAMzH,GACnCmD,EAAMoE,EAAQa,GACpB,IAAIvB,EAAQM,EAAOkB,IAAIlF,GAClB0D,EAIIW,GACLX,EAAMtG,EAAE6H,EAAW5I,IAJnBqH,EAAQc,EAAkBxE,EAAKiF,GAC/BvB,EAAMH,KAKVuB,EAAWK,IAAInF,EAAK6E,EAAWhI,GAAK6G,GAChC1D,KAAO4E,GACPI,EAAOG,IAAInF,EAAKtD,KAAK0I,IAAIvI,EAAI+H,EAAY5E,KAEjD,MAAMqF,EAAY,IAAI7C,IAChB8C,EAAW,IAAI9C,IACrB,SAAS5E,EAAO8F,GACZD,EAAcC,EAAO,GACrBA,EAAM6B,EAAE7H,EAAM+G,GACdT,EAAOmB,IAAIzB,EAAM1D,IAAK0D,GACtBe,EAAOf,EAAM8B,MACbb,IAEJ,KAAOb,GAAKa,GAAG,CACX,MAAMc,EAAYZ,EAAWF,EAAI,GAC3Be,EAAYvB,EAAWL,EAAI,GAC3B6B,EAAUF,EAAUzF,IACpB4F,EAAUF,EAAU1F,IACtByF,IAAcC,GAEdjB,EAAOgB,EAAUD,MACjB1B,IACAa,KAEMG,EAAWjC,IAAI+C,IAKf5B,EAAOnB,IAAI8C,IAAYN,EAAUxC,IAAI8C,GAC3C/H,EAAO6H,GAEFH,EAASzC,IAAI+C,GAClB9B,IAEKkB,EAAOE,IAAIS,GAAWX,EAAOE,IAAIU,IACtCN,EAASxC,IAAI6C,GACb/H,EAAO6H,KAGPJ,EAAUvC,IAAI8C,GACd9B,MAfAS,EAAQmB,EAAW1B,GACnBF,KAiBR,KAAOA,KAAK,CACR,MAAM4B,EAAYvB,EAAWL,GACxBgB,EAAWjC,IAAI6C,EAAU1F,MAC1BuE,EAAQmB,EAAW1B,GAE3B,KAAOW,GACH/G,EAAOiH,EAAWF,EAAI,IAC1B,OAAOE,EAaX,SAASgB,EAAkBC,EAAQC,GAC/B,MAAMrD,EAAS,GACTsD,EAAc,GACdC,EAAgB,CAAEjK,QAAS,GACjC,IAAIa,EAAIiJ,EAAOlJ,OACf,KAAOC,KAAK,CACR,MAAMiH,EAAIgC,EAAOjJ,GACX8H,EAAIoB,EAAQlJ,GAClB,GAAI8H,EAAG,CACH,IAAK,MAAM3E,KAAO8D,EACR9D,KAAO2E,IACTqB,EAAYhG,GAAO,GAE3B,IAAK,MAAMA,KAAO2E,EACTsB,EAAcjG,KACf0C,EAAO1C,GAAO2E,EAAE3E,GAChBiG,EAAcjG,GAAO,GAG7B8F,EAAOjJ,GAAK8H,OAGZ,IAAK,MAAM3E,KAAO8D,EACdmC,EAAcjG,GAAO,EAIjC,IAAK,MAAMA,KAAOgG,EACRhG,KAAO0C,IACTA,EAAO1C,QAAOzD,GAEtB,OAAOmG,EAEX,SAASwD,GAAkBC,GACvB,MAA+B,iBAAjBA,GAA8C,OAAjBA,EAAwBA,EAAe,GA4JtF,SAASC,GAAiB1C,GACtBA,GAASA,EAAMH,IAKnB,SAAS8C,GAAgBzF,EAAWnD,EAAQI,EAAQyI,GAChD,MAAMtD,SAAEA,EAAQ/B,SAAEA,EAAQsF,WAAEA,EAAUrD,aAAEA,GAAiBtC,EAAUI,GACnEgC,GAAYA,EAASuC,EAAE9H,EAAQI,GAC1ByI,GAEDjE,GAAoB,KAChB,MAAMmE,EAAiBvF,EAASwF,IAAIzL,GAAK0L,OAAOlL,GAC5C+K,EACAA,EAAWrF,QAAQsF,GAKnBnL,EAAQmL,GAEZ5F,EAAUI,GAAGC,SAAW,MAGhCiC,EAAa3H,QAAQ8G,GAEzB,SAASsE,GAAkB/F,EAAWxC,GAClC,MAAM4C,EAAKJ,EAAUI,GACD,OAAhBA,EAAGgC,WACH3H,EAAQ2F,EAAGuF,YACXvF,EAAGgC,UAAYhC,EAAGgC,SAAS3E,EAAED,GAG7B4C,EAAGuF,WAAavF,EAAGgC,SAAW,KAC9BhC,EAAGjF,IAAM,IAGjB,SAAS6K,GAAWhG,EAAW/D,IACI,IAA3B+D,EAAUI,GAAG3E,MAAM,KACnBwF,EAAiBX,KAAKN,GAxvBrBwB,IACDA,GAAmB,EACnBH,EAAiB4E,KAAKpE,IAwvBtB7B,EAAUI,GAAG3E,MAAMyK,KAAK,IAE5BlG,EAAUI,GAAG3E,MAAOQ,EAAI,GAAM,IAAO,GAAMA,EAAI,GAEnD,SAASkK,GAAKnG,EAAW1B,EAAS8H,EAAUC,EAAiBC,EAAWC,EAAOC,EAAe/K,EAAQ,EAAE,IACpG,MAAMgL,EAAmB3G,EACzBC,EAAsBC,GACtB,MAAMI,EAAKJ,EAAUI,GAAK,CACtBgC,SAAU,KACVjH,IAAK,KAELoL,MAAAA,EACAzE,OAAQ/H,EACRuM,UAAAA,EACAI,MAAOpM,IAEP+F,SAAU,GACVsF,WAAY,GACZgB,cAAe,GACftE,cAAe,GACfC,aAAc,GACdsE,QAAS,IAAIzC,IAAIsC,EAAmBA,EAAiBrG,GAAGwG,QAAUtI,EAAQsI,SAAW,IAErFlG,UAAWpG,IACXmB,MAAAA,EACAoL,YAAY,EACZC,KAAMxI,EAAQzB,QAAU4J,EAAiBrG,GAAG0G,MAEhDN,GAAiBA,EAAcpG,EAAG0G,MAClC,IAAIC,GAAQ,EAkBZ,GAjBA3G,EAAGjF,IAAMiL,EACHA,EAASpG,EAAW1B,EAAQiI,OAAS,IAAI,CAACtK,EAAG+K,KAAQC,KACnD,MAAMtK,EAAQsK,EAAKjL,OAASiL,EAAK,GAAKD,EAOtC,OANI5G,EAAGjF,KAAOmL,EAAUlG,EAAGjF,IAAIc,GAAImE,EAAGjF,IAAIc,GAAKU,MACtCyD,EAAGyG,YAAczG,EAAGsG,MAAMzK,IAC3BmE,EAAGsG,MAAMzK,GAAGU,GACZoK,GACAf,GAAWhG,EAAW/D,IAEvB+K,KAET,GACN5G,EAAG0B,SACHiF,GAAQ,EACRtM,EAAQ2F,EAAGiC,eAEXjC,EAAGgC,WAAWiE,GAAkBA,EAAgBjG,EAAGjF,KAC/CmD,EAAQzB,OAAQ,CAChB,GAAIyB,EAAQ4I,QAAS,CAEjB,MAAMC,EAvxClB,SAAkBzJ,GACd,OAAO0J,MAAMC,KAAK3J,EAAQ4J,YAsxCJC,CAASjJ,EAAQzB,QAE/BuD,EAAGgC,UAAYhC,EAAGgC,SAASoF,EAAEL,GAC7BA,EAAMxM,QAAQwC,QAIdiD,EAAGgC,UAAYhC,EAAGgC,SAASO,IAE3BrE,EAAQmJ,OACR5E,EAAc7C,EAAUI,GAAGgC,UAC/BqD,GAAgBzF,EAAW1B,EAAQzB,OAAQyB,EAAQrB,OAAQqB,EAAQoH,eAEnE7D,IAEJ9B,EAAsB0G,GAkD1B,MAAMiB,GACFC,WACI5B,GAAkB6B,KAAM,GACxBA,KAAKD,SAAW5N,EAEpB8N,IAAIrH,EAAMwB,GACN,MAAMtB,EAAakH,KAAKxH,GAAGM,UAAUF,KAAUoH,KAAKxH,GAAGM,UAAUF,GAAQ,IAEzE,OADAE,EAAUJ,KAAK0B,GACR,KACH,MAAM8F,EAAQpH,EAAUqH,QAAQ/F,IACjB,IAAX8F,GACApH,EAAUsH,OAAOF,EAAO,IAGpCG,KAAKC,GAtzDT,IAAkBC,EAuzDNP,KAAKQ,QAvzDCD,EAuzDkBD,EAtzDG,IAA5B3N,OAAO8N,KAAKF,GAAKnM,UAuzDhB4L,KAAKxH,GAAGyG,YAAa,EACrBe,KAAKQ,MAAMF,GACXN,KAAKxH,GAAGyG,YAAa,ICj2DjC,MAAMyB,GAAmB,GCCzBC,OAAOC,kBAAoB,GA6DpB,MAAMC,GAXb,WACC,MAAMC,UAAEA,EAASnE,IAAEA,EAAGzC,OAAEA,GDpCzB,SAAkBnF,EAAOgM,EAAQ5O,GAC7B,IAAI6O,EACJ,MAAMC,EAAc,IAAIjH,IACxB,SAAS2C,EAAIuE,GACT,GAAIhO,EAAe6B,EAAOmM,KACtBnM,EAAQmM,EACJF,GAAM,CACN,MAAMG,GAAaT,GAAiBtM,OACpC,IAAK,MAAMgN,KAAcH,EACrBG,EAAW,KACXV,GAAiBhI,KAAK0I,EAAYrM,GAEtC,GAAIoM,EAAW,CACX,IAAK,IAAI9M,EAAI,EAAGA,EAAIqM,GAAiBtM,OAAQC,GAAK,EAC9CqM,GAAiBrM,GAAG,GAAGqM,GAAiBrM,EAAI,IAEhDqM,GAAiBtM,OAAS,IAuB1C,MAAO,CAAEuI,IAAAA,EAAKzC,OAlBd,SAAgBzH,GACZkK,EAAIlK,EAAGsC,KAiBW+L,UAftB,SAAmBtO,EAAK6O,EAAalP,GACjC,MAAMiP,EAAa,CAAC5O,EAAK6O,GAMzB,OALAJ,EAAY3G,IAAI8G,GACS,IAArBH,EAAYK,OACZN,EAAOD,EAAMpE,IAAQxK,GAEzBK,EAAIuC,GACG,KACHkM,EAAY7F,OAAOgG,GACM,IAArBH,EAAYK,OACZN,IACAA,EAAO,SCCaO,CAAS,GAE5C,MAAO,CACNT,UAAAA,EACAU,UAAW,IAAMtH,GAAOiC,GAAKA,EAAI,IACjCsF,UAAW,IAAMvH,GAAOiC,GAAKA,EAAI,IACjCuF,MAAO,IAAM/E,EAAI,IAIGgF,GACTC,GAAc,IA5D3B,MAEIC,cACI7B,KAAK8B,OAASnB,OAAOC,kBAGzBmB,UAAUC,QACyBjO,IAA1BiM,KAAK8B,OAAOE,KACbhC,KAAK8B,OAAOE,IAAY,GAIhCC,aAAaD,QACsBjO,IAA1BiM,KAAK8B,OAAOE,WACNhC,KAAK8B,OAAOE,GAI3BE,UAAUF,GACN,YAAkCjO,IAA1BiM,KAAK8B,OAAOE,GAGxBG,YAAYH,GACHhC,KAAKkC,UAAUF,GAChBhC,KAAKiC,aAAaD,GAElBhC,KAAK+B,UAAUC,GAIvBI,UAAUC,GACN,IAAM,IAAI9B,KAAO8B,EACRrC,KAAKkC,UAAU3B,EAAI+B,SACpBtC,KAAK8B,OAAOvB,EAAI+B,OAAS/B,GAKrCgC,kBACI,IAAIC,EAAS,GACb,IAAM,IAAIC,KAAMzC,KAAK8B,OACjBU,EAAO9J,KAAKsH,KAAK8B,OAAOW,IAE5B,OAAOD,yFCfkBjP,4BACaA,4BACFA,0BACoBA,6XAJhE6B,SACCJ,qBACAA,qBACAA,qBACAA,qBACAA,mBACQzB,wBALwBA,eACaA,eACFA,gBACoBA,wBAEvDA,uCA3BCmP,GAAaC,MACH,UAAbA,QACG,aAEHC,EAAQC,SAASF,cACCG,KAAKF,GAAQG,mBAAmB,iCATpDC,EAcAC,EACAC,EAKAC,SAzBOC,YACAd,YACAe,eACAC,oLAGRN,OAA0BjP,IAAbuP,EAA0BA,EAASC,OAAO,EAAE,KAAO,UAAY,6BAgB5EN,EAAeG,EAAQV,GAAaU,EAAMI,SAAW,uBACrDN,EAAeE,EAAQV,GAAaU,EAAMK,SAAW,uBAGrDN,EAAcE,EAAQA,EAAME,OAAO,EAAE,IAAM,MAAS,6QCqDtDnO,2BAAkB7B,mEAaVA,0BAALa,yNAAKb,aAALa,+HAAAA,8DAAAA,0JAGcb,0MAFf6B,SACCJ,6DACczB,kMAjBZA,cAaAA,6DAhBoCA,+CACIA,6BACFA,yCAIoBA,0BAC1DA,gEAE8C,oBAA2CA,wEAT9DA,8kBAFlC6B,SACCJ,OACCA,qBAAuDA,iBAAqCzB,YAC5FyB,qBACAA,2CAIAA,qBACAA,qBACAA,OACCA,cAA8DA,qBAGhEA,mBACQzB,YAERyB,kEAfoHzB,uCAA1EA,wCAATA,wBAA4DA,wBAC/CA,wBACFA,MACtCA,2EAG0DA,wBAC1DA,sBAEyFA,+BAIvFA,MAGFA,kMA3EGmP,GAAaC,MACH,UAAbA,QACG,aAEHC,EAAQC,SAASF,cACCG,KAAKF,GAAQG,mBAAmB,mCAWpDE,EACAC,SA5BOQ,YACApB,YACAe,YACAD,cACAO,WACAlD,eACA6C,eACAM,KAcPC,GAAgB,EAGhBC,GAAc,EASdC,GAAgB,SA4BAlD,GAAOC,WAAU/L,QAEpC+O,EAAclC,GAAYM,UAAUI,4SAtDlC0B,EAAUvD,EAAKwD,KAAK,yBAgBpBH,EAAclC,GAAYM,UAAUI,0BAKpCW,EAAeP,GAAaU,EAAMI,iCAClCN,EAAeR,GAAaU,EAAMK,8BAIhB1P,IAAb6P,GACiC,mBAA5BjD,OAAOuD,uBAClBH,EAAgBpD,OAAOuD,oBAClBH,OACJF,EAAgBrE,MAAM2E,QAAQP,IAAkC,IAApBA,EAASxP,8CAOlD2P,GAA0D,mBAAjCpD,OAAOyD,uBACpCzD,OAAOyD,sBAAsBL,EAAczB,aAIxB+B,GACpBzC,GAAYO,YAAYG,GACnBwB,EACJjD,GAAOW,YAEPX,GAAOY,4BAcoFqC,sYCW9F1O,mKAdiC7B,4BACaA,4BACFA,0BACoBA,0BAC1DA,uCAEqBA,8CAAuE,oBAA2CA,6jBAV7I6B,SAECJ,iBAAqCzB,YAErCyB,qBACAA,qBACAA,qBACAA,qBACAA,qBACAA,OACAA,cAA+CA,cAA8DA,qBAE7GA,mBACQzB,4CAXoDA,uCAAvBA,eAELA,gBACaA,gBACFA,iBACoBA,iBAC1DA,eAEqBA,iBAAkHA,wBAGpIA,4EAdJA,MAA2B,SAAjBA,KAAMkQ,2MAxCXf,GAAaC,MACH,UAAbA,QACG,aAEHC,EAAQC,SAASF,cACCG,KAAKF,GAAQG,mBAAmB,mCAlBpDC,EAKAsB,EAkBArB,EACAC,EAKAC,EAGAoB,YA5COC,YACAd,YACAN,YACAd,SACAmC,WACAhE,YACAiE,YACAC,cACAhB,YACAN,eACAC,KAWPQ,GAAc,SAqCEjD,GAAOC,WAAU/L,QAEpC+O,EAAclC,GAAYM,UAAUI,iYA/ClCU,OAA0BjP,IAAbuP,EAA0BA,EAASC,OAAO,EAAE,KAAO,UAAY,gCAE5ES,EAAUvD,EAAOA,EAAKwD,KAAK,MAAQ,0BAInCK,EAAgBK,EAAQA,EAAMC,QAAQ,GAAK,qBAG3Cd,EAAclC,GAAYM,UAAUI,sBAgBpCW,EAAeG,EAAQV,GAAaU,EAAMI,SAAW,sBACrDN,EAAeE,EAAQV,GAAaU,EAAMK,SAAW,2BAGrDN,EAAcE,EAAQA,EAAME,OAAO,EAAE,IAAM,MAAS,8BAGpDgB,EAAgBZ,EAAUA,EAAQJ,OAAO,EAAE,IAAM,MAAQ,sCAEvCc,GACpBA,EAAGQ,kBACHjD,GAAYO,YAAYG,GACnBwB,EACJjD,GAAOW,YAEPX,GAAOY,0CAe4BqC,ySCzCUvQ,YAArBA,0LADZA,KAAMkR,kBAAYK,4CAA/B1P,wDAA+D7B,sBAA2BA,6CAC5CA,qBAArBA,oLADZA,KAAMkR,oKADblR,gBAAiBA,KAAMkR,mBAA5BrQ,mIADS2Q,+BAAZ3P,4EACQ7B,6EAALa,kIANE2Q,GAAuB,iBACvBD,GAAuB,+CAvBhBE,sBACAC,WAGLC,EAAWvM,oHAEGnC,OACf2O,EAAM3O,EAAM4O,cAAcX,GAC9BS,EAAS,WACRtM,KAAM,QACN1C,KAAO,SAAWiP,cAIC3O,OAChB2O,EAAM3O,EAAM4O,cAAcX,GAC9BS,EAAS,WACRtM,KAAM,OACN1C,KAAO,QAAUiP,yPCyBhB/P,oDAA0C7B,oBAAyBA,4NA1CjE2R,EAAWvM,QAEb0M,GAAWC,EAAG,EAAGC,EAAG,YAYfC,EAAUxM,GACf2H,OAAO/J,oBAAoB,YAAa6O,GAAU,GAClD9E,OAAO/J,oBAAoB,UAAW4O,GAAW,GACjDN,EAAS,WACLQ,IAAQ,kBAKPD,EAASzM,WAECjF,IADHiF,EAAE/D,oBAGR0Q,EAAe3M,EAAE4M,MAAQP,EAAOC,EAChCO,EAAgB7M,EAAE8M,MAAQT,EAAOE,EACvCL,EAAS,WACLQ,IAAQ,OACRK,QAAWJ,EACXK,QAAWH,kEA5BC7M,GACJA,EAAE/D,SAEVoQ,EAAOC,EAAItM,EAAE4M,MACbP,EAAOE,EAAIvM,EAAE8M,MACbnF,OAAOhK,iBAAiB,YAAa8O,GAAU,GAC/C9E,OAAOhK,iBAAiB,UAAW6O,GAAW,kHCiMlB,qNAAdjS,qCALlBA,4BACuE,gIAAnDA,qEAFHA,wKADLA,iDAAhB6B,SACCJ,qBAEEA,qBAEFA,yEAF2DiR,oBAFC1S,oBAAuBA,sCAChFA,oCACoBA,kDAFHA,yKADLA,iJA9LX2S,GAAe,YAkFVD,GAAajN,OACjBmN,EAASnN,EAAE/D,OAAOwP,MACjB0B,OAEAC,WADMD,EAAOE,QAAQ,aAAa,UAElCC,EAAQtQ,SAASuQ,eAAeH,WACrBrS,IAAVuS,SACLA,EAAM5O,MAAM8O,QAAU,iBAMfC,GAAWC,EAAGC,OAClBC,EAAW5Q,SAASuQ,eAAe,2BAClCK,GAEJA,EAASC,kBAAmB,MAExB/L,EAAI8L,EAASE,4BAEbR,EAAQtQ,SAASuQ,wBAAwBG,QACxCJ,OACAS,EAAKT,EAAMQ,wBACXE,EAAI9S,KAAK+S,MAAMF,EAAGG,OAASpM,EAAEqM,KAAOR,EACxCC,EAASlP,MAAM0P,OAASJ,EAAI,+DA/GpB3D,uBACAgE,YACAnH,EAAQ,KAOfmF,GAAWC,EAAG,EAAGC,EAAG,GAEpB+B,EAAiB,EACjBC,EAAkB,WAKbC,EAAUlB,GACbA,IACJgB,EAAiBG,WAAWC,iBAAiBpB,EAAO,MAAMqB,iBAAiB,SAAStB,QAAQ,KAAM,KAClGkB,EAAkBE,WAAWC,iBAAiBpB,EAAO,MAAMqB,iBAAiB,UAAUtB,QAAQ,KAAM,KACvFC,EAAMQ,wBAAwBc,KAC9BtB,EAAMQ,wBAAwBK,SAKzCU,EAAqBlV,OAAOP,UAAUiV,YAkHjCS,EAAUpB,OACdJ,EAAQtQ,SAASuQ,wBAAwBG,KACxCJ,IACJA,EAAM5O,MAAMqQ,MAASpH,OAAOqH,WAAWH,EAAmBI,EAAK/B,GAAe,KAC9EI,EAAM5O,MAAM0P,OAAUzG,OAAOuH,YAAYL,EAAmBb,EAAKd,GAAe,KAChFsB,EAAUlB,aAiBH6B,EAAQnP,GAChB2H,OAAO/J,oBAAoB,YAAawR,GAAW,YAG3CC,EAAUrP,OACdsP,EAAQtP,EAAE/D,OAAOwP,MAChB6D,OACAC,EAAMD,EAAMjC,QAAQ,aAAa,IACjCD,WAAmBmC,QACnBjC,EAAQtQ,SAASuQ,eAAeH,OAC7BE,mBA5GYiC,OAChBC,EAAiB7H,OAAO8H,qBACJ1U,IAAnByU,GACgB,iBAARD,IAAmBA,EAAM1F,SAAS0F,QAC1CG,EAAMF,EAAerI,QAAQoI,MAC5BG,GAAM,GACVF,EAAepI,OAAOsI,EAAI,GAC1BF,EAAe9P,KAAK6P,OAChBI,EApEQ,YAqEFC,KAAOJ,OACZpC,WAAmBwC,IACnBtC,EAAQtQ,SAASuQ,eAAeH,GAC/BE,IACJA,EAAM5O,MAAMmR,OAASF,QAgGxBG,CAAYP,GACZlD,EAAOC,EAAItM,EAAE+P,QAAUzC,EAAM0C,WAC7B3D,EAAOE,EAAIvM,EAAEiQ,QAAU3C,EAAM4C,UAC7BvI,OAAOhK,iBAAiB,YAAayR,GAAW,aAIzCA,EAAUpP,OACdsN,EAAQtQ,SAASuQ,wBAAwBrG,aAC9BnM,IAAVuS,GACLA,EAAM5O,MAAMyR,SAAW,eACnBhC,EAAMjT,KAAKC,IAAK6E,EAAEiQ,QAAU5D,EAAOE,EAAG,GACtCqC,EAAO1T,KAAKC,IAAK6E,EAAE+P,QAAU1D,EAAOC,EAAG,GAC3CgB,EAAM5O,MAAMyP,IAAMA,EAAM,KACxBb,EAAM5O,MAAMkQ,KAAOA,EAAO,aA/J3BrP,YACKiQ,EAAiB7H,OAAO8H,mBACJ1U,IAAnByU,IACJ7H,OAAO8H,gBACPD,EAAiB7H,OAAO8H,cAEzBD,EAAe9P,KAAKwH,QAILnM,IADHiC,SAASuQ,wBAAwBrG,QAE7C4H,EAAU5H,GAEMlK,SAASuQ,4BAA4BrG,KAE3CvJ,iBAAiB,YAAa0R,GAAW,GACnD1H,OAAOhK,iBAAiB,UAAWwR,GAAS,GAC5CxH,OAAOhK,iBAAiB,WAAWqC,OAChB,IAAbA,EAAEoQ,aACF9C,EAAQtQ,SAASuQ,wBAAwBrG,aAC9BnM,IAAVuS,SACLA,EAAM5O,MAAM8O,QAAU,WAIxB7F,OAAOhK,iBAAiB,UAAUqC,IACjC8O,EAAU5H,MAGXS,OAAO0I,sBAAyBnJ,cA4FVwG,OAClBJ,EAAQtQ,SAASuQ,wBAAwBG,KACxCJ,GAAkC,UAAxBA,EAAM5O,MAAM8O,UAC1BF,EAAM5O,MAAMyP,IAAM,MAClBb,EAAM5O,MAAMkQ,KAAO,MACnBtB,EAAM5O,MAAMqQ,MAASpH,OAAOqH,WAAWH,EAAmBI,EAAK/B,GAAe,KAC9EI,EAAM5O,MAAM0P,OAAUzG,OAAOuH,YAAYL,EAAmBb,EAAKd,GAAe,KAChFI,EAAM5O,MAAM8O,QAAU,QACtB8C,iBAAmB7C,GAAWC,EAAG,KAAM,KAExC4C,iBAAmB7C,GAAWC,EAAG,KAAM,IArGtC6C,CAAcrJ,6KA0DK1J,MACfA,GAASA,EAAMqC,UACM,QAApBrC,EAAMqC,OAAO6M,SACb8D,EAAQhT,EAAMqC,OAAOkN,QACrB0D,EAAQjT,EAAMqC,OAAOmN,cAEnB+B,EAAQT,EAAiBkC,EACzBpC,EAASG,EAAkBkC,GAC7BnD,EAAQtQ,SAASuQ,wBAAwBrG,QAExC6H,EAzHa,MA0HhBzB,EAAM5O,MAAMqQ,MAAQA,EAAQ,MAEzBX,EA5Ha,MA6HhBd,EAAM5O,MAAM0P,OAASA,EAAS,eAGD,QAApB5Q,EAAMqC,OAAO6M,SACpBY,EACJkB,EADIlB,EAAQtQ,SAASuQ,wBAAwBrG,uHCxI1C,SAASwJ,GAAQnJ,GAEpB,OADQoJ,KAAKC,MAAMD,KAAKE,UAAUtJ,IAKtC,IAAIuJ,GAAiB,CACjBpG,MAAS,OACTL,MAAU,aACV0G,WAAc,EACd3G,MAAU,CACNK,QAAY,QACZD,QAAY,SAEhBG,QAAY,GACZa,SAAa,aACb/D,KAAS,GACTiE,MAAU,CACNsF,gBAAoB,UACpBC,SAAa,UACbC,OAAW,OACXC,OAAW,QAEfC,WAAe,CACXC,QAAY,GACZC,MAAU,IAEd1G,SAAa,GACbe,MAAU,GAIP,SAAS4F,GAAiBC,EAAeC,GAO5C,YANwB1W,IAAnByW,GACDV,GAAiBU,EACjBE,GAAmB/X,OAAOP,OAAO,CAAEqS,GAAO,EAAGnC,OAAW,GAAIwH,KAE5DU,EAAiBV,GAEhBW,EACM9X,OAAOP,OAAO,GAAGsY,IAErBhB,GAAQc,GAGnB,IAAIE,GAAmB/X,OAAOP,OAAO,CAAEqS,GAAO,EAAGnC,OAAW,GAAIwH,IAIhE,SAASa,GAAkBC,EAAMC,GAC7B,IAAI1O,EAAIyO,EAAQC,EAAazW,OAC7B,KAAQ+H,EAAI,GACR0O,EAAanS,MAAK,GAClByD,IAMD,SAAS2O,GAAW9F,EAAO6F,EAAaE,EAAcC,GACzD,IAAIpL,EAAIoF,EAAO5Q,OACX6W,EAAKJ,EAAazW,OAElB8W,OAAqBnX,IAAXiX,EAA0BD,EAAc,EAAMC,EAAO,EAEnE,IAAM,IAAI3W,EAAI,EAAGA,EAAIuL,EAAGvL,IACpB,GAAM6W,EAAO7W,EAAK4W,EAAK,CACnB,IAAIE,EAAMN,EAAaK,EAAO7W,GAC9B,IAAa,IAAR8W,EACDA,EAAI1G,GAAKpQ,EAAE,EACX2Q,EAAO3Q,GAAK8W,MACT,CACH,IAAIC,EAAM1B,GAAQgB,IAClBU,EAAI3G,GAAKpQ,EAAE,EACX2Q,EAAO3Q,GAAK+W,OAEb,CACH,IAAIA,EAAM1B,GAAQgB,IAClBU,EAAI3G,GAAKpQ,EAAE,EACX2Q,EAAO3Q,GAAK+W,EAGpB,OAAOpG,EAkKJ,SAASqG,GAAuBC,EAAQC,EAAOC,EAAcX,EAAaY,GAI7E,GAAKD,EAAgB,CACjB,IAAIrV,EAAOqV,EAAcrV,KACzB,GAAKA,EAAO,CAGJA,OADmBpC,IAAlB0X,EACMA,EAActV,GAxB9B,SAAqBA,GAWxB,OAVkBA,EAAK8H,KAAIyN,IACvBA,EAAMrI,MAAQqI,EAAMrI,MAAQsI,mBAAmBD,EAAMrI,OAAS,WAC9DqI,EAAMlH,SAAWkH,EAAMlH,SAAWmH,mBAAmBD,EAAMlH,UAAY,cACjEkH,EAAMjL,MAAQjB,MAAM2E,QAAQuH,EAAMjL,QACpCiL,EAAMjL,KAAOiL,EAAMjL,KAAKxC,KAAIzG,GACjBmU,mBAAmBnU,MAG3BkU,KAiBQE,CAAYzV,GAGvB,IAAI8U,EAAKO,EAAcZ,MACvB,QAAgB7W,IAAXwX,EAID,OAHKN,EAAK9U,EAAK/B,QACXuW,GAAkBM,EAAG9U,GAElB,CAAC,EAAE8U,EAAG9U,GACV,CAEE8U,EAAKJ,EAAazW,QACnBuW,GAAkBM,EAAGJ,GAGzB,IAAI1O,EAAIhG,EAAK/B,OACb,IAAM,IAAIC,EAAI,EAAGA,EAAI8H,EAAG9H,IACpBwW,EAAaxW,EAAIiX,GAAWnV,EAAK0V,QAKzC,MAAO,CA/BK,EA+BUZ,EAAGJ,IAIjC,MAAO,EAAC,GAAM,GAAM,GC1RjB,SAASiB,KACZ,IACIC,EAAY,IAGZC,EAAY,IAGZ/D,EAAI/T,KAAKC,IAPI,IAOWwM,OAAOqH,YACnCC,EAAI/T,KAAK+X,IAAIF,EAAU9D,GAGvB,IAAIjB,EAAI9S,KAAKC,IARI,IAQWwM,OAAOuH,aAGnC,GAFAlB,EAAI9S,KAAK+X,IAAID,EAAUhF,GAElBiB,EAAI,IAAM,CACX,IAAIiE,EACAC,EAGAC,EAAU,GACdF,EAFc,GAEME,EACpBD,GAAKH,EAAYhF,OAEjB,IAAIqF,EAAUF,IAAcC,EAIxBE,EAAU,GASd,OARAJ,EAFc,IAEMI,EACpBH,GAAKJ,EAAY9D,QAOV,CAAEA,EALKkE,IAAcG,EAKJtF,EAAMqF,GAC3B,CACH,IAAIH,EACAC,EAGAC,EAAU,GACdF,EAFc,GAEME,EACpBD,GAAKH,EAAYhF,OAEjB,IAAIqF,EAAUF,IAAcC,EAIxBE,EAAWrE,EAAI,IAAO,GAAO,IASjC,OARAiE,EAFc,EAEMI,EACpBH,GAAKJ,EAAY9D,QAOV,CAAEA,EALKkE,IAAcG,EAKJtF,EAAMqF,2FC7ClC9Y,KAAM8P,6EADI9P,KAAMkR,uDAAlBrP,+CACE7B,KAAM8P,oCADI9P,KAAMkR,yEADXlR,gBAAqBA,KAAMkR,mBAAhCrQ,wLAFJgB,SACCJ,oEACQzB,uIAZGgZ,YAGS1L,GAAOC,WAAU/L,QAEpCwX,EAAa3K,GAAYW,2JCL3B,IAAIiK,GAAiB,GACjBC,GAAe,GACfC,GAAa,GAEbC,GAAkB,KAKtB,SAASC,KACL,MAAO,uCAAuCvG,QAAQ,SAAS,SAAStL,GACtE,IAAID,EAAoB,GAAhB5G,KAAK2Y,SAAgB,EAC7B,OADyC,KAAL9R,EAAWD,EAAS,EAAJA,EAAU,GACrDgS,SAAS,OAWxB,SAASC,KAEL,IAAIC,EAAW,GACXC,EAASnK,KAAKoK,MAClB,IAAM,IAAIzK,KAAM+J,GAAiB,CAEvBS,EADSR,GAAahK,GAtBT,OAwBfuK,EAAStU,KAAK+J,GAGtBuK,EAASja,SAAS0P,WACPgK,GAAahK,UACb+J,GAAe/J,MAG1BuK,EAAW,GAIR,SAASG,GAAW3V,GAClBkV,GAAWtY,QAAU,KACG,OAApBuY,KACDA,GAAkBrD,WAAWyD,GAAe,MAGpD,IAAIK,EA/BR,WACI,IAAI3K,EAAKmK,KACT,KAAQF,GAAWvM,QAAQsC,IAAO,GAAIA,EAAKmK,KAC3C,OAAOnK,EA4BG4K,GAIV,OAHAb,GAAehV,GAAO4V,EACtBX,GAAajV,GAAOsL,KAAKoK,MACzBR,GAAa/Z,OAAO8N,KAAK+L,4FC2OtBjZ,MAAS2C,0DADI3C,gCAAf6B,2EAwBW7B,gKAAAA,gKAKSA,+FAAAA,mPA9BdA,6BAALa,iEAiBeb,qBAAyB+Z,uBAAmB/Z,+BAO7CA,KAAc8P,MAAME,OAAO,EAAEgK,IAAqB,YAAe,mBAAqBha,MAAkB,4FAKhF,mBAAqBA,MAAkB,+RA3C7C,mJASoG,mBACnIA,mHAgBoB,gBAAQA,uBAAmD,kBAAUA,01BAnBdA,kJAEOA,2HAIlEA,4fAhCvB6B,SAECJ,OACCA,OACCA,cACAA,WAA4DzB,aAE5DyB,cAIAA,cAIDA,OACCA,cAGAA,cACMA,WAA6BzB,aAGpCyB,OAECA,cACAA,WAAqDzB,aACrDyB,cACAA,WAA4DzB,2BAG7DyB,OACCA,wDAAoBzB,aAStByB,cAICA,uBAA4DA,kCAC5DA,QAA4CA,iBAG7CA,+GA1C2CzB,mBAICA,mBAKxBA,yCAI4CA,mBAKrBA,2DACgEA,mBAChEA,uCACuEA,wCAI/DA,oBAcYA,iDAzCDA,UAAAA,wBAezBA,UAAAA,iCAM4CA,oBAA1BA,iCAEiCA,6BAA1BA,UAAAA,2BACxDA,8BAIIA,eAALa,yIAAAA,sBADiBb,0BAaYA,2BAA6DA,oCAK3EA,8CAODA,KAAc8P,MAAME,OAAO,EAAEgK,IAAqB,8WArRjEA,GAAoB,+BAlCbxX,KAsBPyX,IACD/I,GAAI,EAAGvO,qBACPuO,GAAI,EAAGvO,eACPuO,GAAI,EAAGvO,qBAINuX,KAEAC,EAAkBF,EAAe,GACjCG,EAAe,MAIfC,EAAuB,GACvBC,EAAyB,GAEzB/D,EAAiBS,KAEjBuD,EAAgBnb,OAAOP,QAASqS,GAAO,EAAGnC,MAAU,GAAIwH,GACxDY,EAAmB/X,OAAOP,QAASqS,GAAO,EAAGnC,OAAW,GAAIwH,GAG5DiE,GAAiB9F,EAAM,GAAKjB,EAAM,IAEtC+G,EAAejC,SACXkC,cA+CKC,EAAkBC,OACrBC,EAAOzE,GAAQgB,UACnByD,EAAK1J,GAAKyJ,EACHC,EAjDTH,EAAkBtV,KAAKqV,GACvBC,EAAkBtV,KAAKqV,GAEvBxV,aACCoI,OAAOyN,oBAAuBC,YACd1N,OAAOuD,mBACvBvD,OAAOhK,iBAAiB,UAAWqC,QAE9BsV,EAAQxC,KAEZiC,EAAa/G,EAAIsH,EAAMtH,EACvB+G,EAAa9F,EAAIqG,EAAMrG,YA2CrBjD,GACH0F,GAGGG,KAEA0D,EAAgB,EAChBxD,EAAgB,EAEhByD,EAAY,WAEPC,EAAW1N,EAAM2N,MACpB7D,EAAazW,OAAS,UAChBC,EAAI0M,EAAO1M,EAAIqa,EAAKra,QACJ,IAApBwW,EAAaxW,UACV,SAIH,WAGCsa,QACJD,EAAO3D,EAAgB/F,EAAO5Q,OAC9B2M,EAAQgK,EAAgB,EACvB0D,EAAW1N,EAAM2N,GACrBE,EAAa7N,EAAMiE,EAAO5Q,QAE1B0W,GAAW9F,EAAO6F,EAAaE,kBAiElB6D,EAAarD,EAAOsD,OAC9BjP,OAAoB7L,IAAf8a,EAA4B7J,EAAO5Q,OAASya,EACjDvD,OAAsBvX,IAAXwX,EAAyBR,EAAgB,EAAIQ,EACxDuD,EAAMC,mBAAmBpB,GAE7BmB,GAAO,IAAMpB,EAAgBxX,SAIzBkX,EDlJC,SAAoB5V,EAAIwX,GAAa,GAExC,OAAKxX,KAAOgV,GACDA,GAAehV,GAErBwX,EACM7B,GAAW3V,QADtB,EC6IQyX,CAAWH,GAAI,GAEzBxD,EAAUpX,KAAKC,IAAI,EAAEmX,OACjB4D,GACK9B,IAAAA,EACR+B,MAAUL,EACVM,UAAcxP,EACdyF,OAAWiG,WAIP+D,EAAY,cACZhQ,KAAU6P,EAAY9B,OAAO8B,EAAYC,SAASD,EAAYE,aAAaF,EAAY7J,SACvFiK,EAAQC,SAASC,KACjBC,EAAOF,SAAStF,SAChByF,EAAK,KACLlE,QJDAmE,eAAiCC,EAAKV,EAAaW,GAOlD,MAHuC,mBAA3BlP,OAAOmP,iBACfnP,OAAOmP,gBAAgBZ,SAEdW,EAASD,EAAKV,GINNa,IAAqBN,IAAOC,IAAKJ,KAASD,KAAahQ,IAAO6P,EAAaW,WAEhGG,EAAI/E,EAAGgF,GAAM5E,GAAuBC,EAAQC,EAAOC,EAAcX,OACtEE,EAAgBiF,OAChBzB,EAAgBtD,GAChBJ,EAAeoF,GAEO,IAAjBpF,OACJ7F,EAAS8F,GAAW9F,EAAO6F,EAAaE,UAGjC/R,GACRkX,MAAMlX,EAAEmX,iBAMUtP,GAAOC,WAAU/L,IAEpC6M,GAAYQ,UAAU4C,gFAxKAxO,OAElB4Z,EAAM5Z,EAAMqC,OAAO3C,KACnBqS,EAAM6H,EAAI7M,OAAO6M,EAAIjQ,QAFf,OAE8B,GAEpCkQ,EAAQ7Z,EAAMqC,OAAOD,QACzB2P,EAAM1F,SAAS0F,GACfA,SACcxU,IAARwU,GAAuBA,GAAO,GAAOA,EAAMvD,EAAO5Q,YACnDkc,EAAStL,EAAOuD,QACJxU,IAAXuc,IACW,UAAVD,OACJvC,EAAgBwC,GAChBjH,sBAAsB,SAEtBuE,EAAuB0C,EAAOjN,WAC9BwK,EAAyByC,EAAO3M,gCAgDzBtP,EAAI,EAAGA,EAAIma,EAAWna,SAC3BO,EAAIoQ,EACRpQ,EAAEuF,UACF6K,MAAapQ,2BAMVmM,EAAQiE,EAAO5Q,eACTC,EAAI,EAAGA,EAAIma,EAAWna,SAC3B6Z,EAAgBlJ,EAAO5Q,OAC3B8Z,QACIqC,EAAatC,EAAkBC,OACnClJ,MAAaA,EAAQuL,IAIjB9B,EAAW1N,EADNiE,EAAO5Q,QAEhBwa,EAAa7N,EAAMiE,EAAO5Q,YAE1B4Q,EAAS8F,GAAW9F,EAAO6F,EAAaE,gBAOzC4D,oBAIA5D,EAAgB,GAChB4D,oBAIA5D,EAAgBwD,GAChBI,cAGuBtK,GACL,IAAfA,EAAGmM,eACLzF,EAAgB,GAChB6D,eAI2BvK,OAC5B0G,EAAgB,GAChB6D,cAI0BvK,OAC1B0G,EAAgB,GAChB6D,cAoD0BvK,OAC1BoJ,EAAiB7L,GAAYW,mBAC7B8G,sBAAsB,iBAYuCmF,mCAezBb,gCAMkB5C,mCAEOA,mCAIxC2C,EbuXvB,SAAsB7V,GAClB,MAAM4Y,EAAkB5Y,EAAO6Y,cAAc,aAAe7Y,EAAOnB,QAAQ,GAC3E,OAAO+Z,GAAmBA,EAAgB1Y,uCctpBlC,wFAAQ,CACnB9C,OAAQe,SAASuQ,eAAe,YAChC5H,MAAO,CACN5I,KAAM"}