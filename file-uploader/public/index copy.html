<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="author" content="Richard Leddy" />
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
	<meta id="theme-color" name="theme-color" content="#452770">

	<title>Pop Song Blog</title>

	<link rel='icon' type='image/png' href='./favicon.png'>
	<link rel='stylesheet' href='./global.css'>
	<link rel='stylesheet' href='./build/bundle.css'>

<script>
	//
	// ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

	async function media_startup(tracking,protocol,media,counter_link,session) { // _x_link_counter > counter_link
		if ( tracking === undefined ) return false
		if ( protocol === 'ipfs' ) {
			let links = await crypto_ready_counted(counter_link,tracking,session,media)  // src is for checking...
			return links
		} else if ( protocol === 'local' ) {
			let links = await clear_counted(counter_link,tracking,session,media)  // src is for checking...
			return links
		} else {		// default
			counter_link = "localhost:7777"
			let links = await clear_counted(counter_link,tracking,session,media)
			return links
		}
	}

	// ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

	// the counter link is complete, stored in the _x_link_counter field of the meta object

	async function crypto_ready_counted(counter_link,tracking,session,src) {
		//
		let prot = "http:"  // https
		let sp = "//"
		let url = `${prot}${sp}${counter_link}/key-media/${tracking}`
		if ( (typeof session === 'string') && (session.length > 0) ) {
			url += `/${session}`
		}
		//
		try {
			let result = await fetchUrl(url)
			if ( result.status === "OK" ) {
				return result.links
			}
		} catch(e) {
		}
		return false
	}


	async function clear_counted(counter_link,tracking,session,src) {
		//
		let prot = location.protocol
		let sp = "//"
		let url = `${prot}${sp}${counter_link}/clear-media/${tracking}`
		if ( (typeof session === 'string') && session.length > 0 ) {
			url += `/${session}`
		}
		//
		try {
			let result = await fetchUrl(url)
			if ( result.status === "OK" ) {
				return result.links
			}
		} catch(e) {
		}
		return false
	}

	// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
	function retrieve_session() {			// should be stored in some kind of local storage....
		return "a0d9uqkrjsifh"     // test value
	}

	// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
</script>

	<script defer src='./build/bundle.js'></script>	
	<link rel="canonical" href="http://www.popsongnow.com">

	<meta name="description" content="Make you songs safe as soon as you think of them.">
	<style>
		/*csslint important:false*/

/* ==========================================================================
   Pure Base Extras
   ========================================================================== */

/**
 * Extra rules that Pure adds on top of Normalize.css

html {

}
*/

/**
 * Always hide an element when it has the `hidden` HTML attribute.
 */

.hidden,
[hidden] {
    display: none !important;
}

/**
 * Add this class to an image to make it fit within it's fluid parent wrapper while maintaining
 * aspect ratio.
 */
.pure-img {
    max-width: 100%;
    height: auto;
    display: block;
}

		.items {
			display: flex;
			flex-wrap: wrap;
			margin-left: -10px;
			margin-top: -10px;
		}
	
		.items .item {
			flex: 1 0 300px;
			box-sizing: border-box;
			background: -webkit-linear-gradient(to right, rgba(242, 242, 210, 0.3), white));
			background: linear-gradient(to right, rgba(242, 242, 210, 0.3), white );
			color: #171e42;
			padding: 10px;
			margin-left: 10px;
			margin-top: 0px;
		}
	
		.items .extra-i {
			padding-left: 10%;
			padding-bottom: 4px;
			padding-right: 12px;
			font-size: 110%;
			font-family: sans-serif;
		}
	
		.middleBanner {
			text-align: 'center';
			padding-left: 10%;
			padding-right: 10%;
			font-weight:bold;
			color: darkgreen;
			padding-top:4%;
			overflow:auto;
		}

		.applink {
			padding:3px;
			background-color: cornsilk;
			width:inherit;
			min-height: 100%;
			color:darkolivegreen;
			font-weight: bolder;

		}
	
		.extraBanner {
			text-align: 'center';
			padding-left: 10%;
			padding-right: 10%;
			font-weight:bold;
			color: #FF4400;
			padding-top:4%;
		}
	
	
		.fillLowerWrap {
			width: 66%;
			margin-left:0px;
			margin-right:0px;
			padding: 8px;
			margin-top:8px;
			background: -webkit-linear-gradient(to right, white, #FAFAFF);
			background: linear-gradient(to right, white, #FAFAFF );
			margin-left: 10px;
		}
	
		.fitMenuLower {
			width: 95%;
			height: 50%;
			margin-left:0px;
			margin-right:0px;
			padding: 8px;
			margin-top:8px;
			background: -webkit-linear-gradient(to right, white, #FAFAFF);
			background: linear-gradient(to right, white, #FAFAFF );
			margin-left: 10px;
		}
	
		#squashMenu:hover {
			border: 1px solid rgb(230,230,240,0.4);
			padding-top:4px;
			background-color: #EFEFEF;
		}
	
		#squashMenuContainer {
			position:absolute;
			visibility:hidden;
			top : 0; left : 0;
			height:100%;
			width: 55%;
			z-index:100;
			border: rgba(252, 190, 190, 0.4) 2px solid;
			background-color: white;
		}
	
		.fade_able {
			position:absolute;
			visibility:hidden;
			top : 10px; left : 10px;
			height:80%;
			width: 40%;
			z-index:101;
			border: rgba(252, 190, 190, 0.4) 2px solid;
			background-color: white;
			overflow:hidden;
		}

		.solid_able {
			position:absolute;
			visibility:hidden;
			top : 10px; left : 10px;
			height:80%;
			width: 40%;
			z-index:111;
			border: rgba(252, 190, 190, 0.4) 2px solid;
			background-color: white;
			overflow: hidden;
		}

		@media screen and (max-width: 950px) {
			.solid_able {
				width: 90%;
			}
		}

		#thankyou_box {
			position:absolute;
			visibility:hidden;
			top : 25%; left : 25%;
			height:50%;
			width: 50%;
			z-index:150;
			border: rgba(100, 5, 5, 0.6) 2px solid;
			background-color: lightgoldenrodyellow;
			overflow: auto;
		}

		@media screen and (max-width: 1040px) {
			.fade_able {
				width: 60%;
			}
		}

		@media screen and (max-width: 600px) {
			.fade_able {
				width: 90%;
			}
		}

		.fade_able_content {
			height:100%;
			width: 100%;
			overflow:auto;
		}

		.togglebar {
			height:20px;
			visibility:inherit;
			background-color: navy;
			text-align:right;
		}
	
		.closer_x {
			padding:2px;
			color:purple;
			font-weight:bolder;
			border: solid 1px red;
			cursor:pointer;
		}

		@media (max-width: 1225px) {
			.fillLowerWrap {
				visibility : "none";
				height : 0px;
			}
		}

	
		.fillLower {
			border: darkred 2px solid;
			height: 96%;
			width: 96%;
			margin-left: 10px;
			padding:8px;
			background: -webkit-linear-gradient(to right, rgba(252, 252, 240, 0.4), #FEFEFE);
			background: linear-gradient(to right, rgba(252, 252, 240, 0.4), #FEFEFE );
		}
	
		button {
			cursor: pointer;
			font-size: 101%;
			font-weight: bold;
			color: darkblue;
			margin: 2px;
			width:120px;
		}
	
		button:hover {
			background-color : #CACAFF;
			color: darkred;
		}
	
		@media screen and (max-width: 390px) {
			.items .extra-i {
				padding-left: 1%;
			}
		}
	
		@media screen and (max-width: 600px) {
			.items .extra-i {
				padding-left: 3%;
			}
		}
	
		.longviz {
			visibility : "visibile";
			height: 10px;
			background-color:inherit;
		}
	
		@media (max-width: 1040px) {
			.longviz {
				visibility : "none";
				height : 0px;
			}
		}
	
		.shortviz {
			visibility : "none";
			height:0px;
			margin-top:6px;
		}

		@media (max-width: 620px) {
			.shortviz {
				visibility : "visible";
				height:2px;
				background-color:darkgreen;
				margin-bottom:12px;
			}
		}
	
		@media (min-width: 1040px) {
			.shortviz {
				visibility : "visible";
				height:120px;
				border: 2px darkblue solid;
				background-color:#FFFFF6;
				margin-bottom:30px;
				margin-top:5px;
			}
		}
	
		@media (min-width: 380px) {
			.items .item {
				max-width: calc(100% - 20px);
			}
			.items .extra-i {
				padding-left: 3%;
			}
		}
		@media (min-width: 410px) {
			.items .item {
				max-width: calc(100% - 10px);
			}
		}
		@media (min-width: 620px) {
			.items .item {
				max-width: calc(50% - 10px);
			}
		}
		@media (min-width: 830px) {
			.items .item {
				max-width: calc(50% - 10px);
			}
		}
		@media (min-width: 1040px) {
			.items .item {
				max-width: calc(33.33333% - 10px);
			}
		}
		@media (min-width: 1250px) {
			.items .item {
				max-width: calc(25%- 10px);
			}
		}
		@media (min-width: 1460px) {
			.items .item {
				max-width: calc(20% - 10px);
			}
		}
		@media (min-width: 1670px) {
			.items .item {
				min-width: calc(16.66667% - 10px);
			}
		}
	
	
		body {
			border: 1px solid black;
			
			-moz-box-sizing: border-box;
			box-sizing: border-box;
		}


		@media screen and (orientation: portrait) {
			#mainNav {
				width: 100%;
			}
		}

		@media screen and (orientation: landscape) {
			#mainNav {
				width: 100%;
			}
		}
	
		main {
			border-left: solid 3px navy;
			border-top: solid 1px #8833BB;
			padding : 4px;
		}
	
		#mainNav {
			font-family: 'Montserrat', 'Helvetica Neue', Helvetica, Arial, sans-serif;
			font-weight: 700;
			text-transform: uppercase;
			background: blue;
			border-left: solid 3px navy;
			border-top: solid 3px navy;
			border-bottom: solid 3px rgba(252,252,255,0.7);
			min-height: 90px
			padding: 20px
			background: -webkit-linear-gradient(to left, rgba(242, 242, 210, 0.3), white);
			background: linear-gradient(to left, rgba(242, 242, 210, 0.3), white );
			
		}
	
		#mainNav table {
			padding-left: 3%;
		}
	
	
		#mainNav  table  a:focus { outline: none; }
		#mainNav  table  .navbar-brand {
			font-size: 1.1rem;
			color: white;
		}
	
		#mainNav  table  .navbar-brand.active, #mainNav .navbar-brand:active, #mainNav .navbar-brand:focus, #mainNav .navbar-brand:hover {
			color: white;
		}
	
		#mainNav  table  .navbar-nav {
			letter-spacing: 1px; }
	
		#mainNav  table  .navbar-nav li.nav-item {
			display:inline;
		}
	
		
		
		#mainNav  table  .navbar-nav li.nav-item a.nav-link {
			color: darkgreen;
			text-decoration: none;
			vertical-align: top;
			padding-right: 10px;
		}
	
		#mainNav  table  .navbar-nav li.nav-item a.nav-link:hover {
			color: #18BC9C;
			outline: none;
			
		}
	
	
		#mainNav  table  .navbar-nav a.nav-text {
			background-color : rgba(242,222,255,0.6);
			border-radius: 25px;
			margin-bottom: 9px;
			margin-right: 6px;
			white-space: nowrap;
		}


		#mainNav  table  .navbar-nav li.nav-item a.nav-link:active, #mainNav .navbar-nav li.nav-item a.nav-link:focus { color: white; }
		
		.footer-list li {
			list-style-type: none;
		}
	
		.footer-list li a:hover { color: gold; }
		
		.hover_group {
			cursor:pointer;
		}
	
		.hover_group rect {
			fill:#e6e6e6;
		}
	
		.hover_group:hover rect {
			fill: #F6F6e6;
		}
	
		footer {
			padding:10px;
			background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2 );
			background: linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2  );
			text-align: center;
			font-size: 0.85em;
		}
	
		footer a {
			text-decoration:none;
			color:darkgreen;
			font-weight:bold;
			font-style: italic;
		}
	
		.copiouslink:hover {
			fill:navy;
		}
		.copiouslink {
			fill:black;
		}
	
		* {margin: 0; padding: 0; box-sizing: border-box}
		
		.PhIOtjDr_0 {
			fill:none;
			stroke:#1c1448;
			stroke-width:4.59875107;
			stroke-miterlimit:4;
			stroke-dasharray: 2948 2950;
			stroke-dashoffset: 2949;
			animation: PhIOtjDr_draw 6666ms ease-in forwards;
		}

		@keyframes PhIOtjDr_draw {
			100% {stroke-dashoffset: 0}
		}

		@keyframes PhIOtjDr_fade {
			0% {stroke-opacity: 1}
			97.1830985915493% {stroke-opacity: 1}
			100% {stroke-opacity: 0}
		}
	
		.form_el {
			border:lightgray solid 1px;
			padding:6px;
			margin:2px;
			width:80%;
		}

		.form_el_inner {
			border:lightgray solid 1px;
			padding:6px;
			margin:2px;
			width:100%;
		}
	
		label {
			font-weight:bold;
			color:darkgreen;
			width:35%;
		}

		.field_el {
			width:65%;
		}
	
		@media (max-width: 1040px) {
			.field_el {
				width:94%;
				margin-left:3%;
				margin-right:3%;
			}
		}

		#contact_box {
			background: -webkit-linear-gradient(to right, rgba(252, 252, 240, 1.0), #FEFEFE));
			background: linear-gradient(to right, rgba(252, 252, 240, 1.0), #FEFEFE );
		}
	
		.textarea_field_el {
			width: 94%;
			margin:3%;
		}
	
		.error-message {
			visibility:hidden;
			width:75%;
			font-weight:bolder;
			color:red;
			background-color:white;
			border: solid 1px orange;
			padding:2px;
			margin:3px;
		}

		/* The Modal (background) */
		.modal {
		  display: none; /* Hidden by default */
		  position: relative; /* Stay in place */
		  z-index: 1; /* Sit on top */
		  left: 0;
		  top: 0;
		  width: 100%; /* Full width */
		  height: 100%; /* Full height */
		  overflow: auto; /* Enable scroll if needed */
		  background-color: rgb(0,0,0); /* Fallback color */
		  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
		  -webkit-animation-name: fadeIn; /* Fade in the background */
		  -webkit-animation-duration: 0.4s;
		  animation-name: fadeIn;
		  animation-duration: 0.4s
		}

		/* Modal Content */
		.modal-content {
		  position: inherit;
		  top: 0;
		  background-color: #fefefe;
		  width: 100%;
		  -webkit-animation-name: slideIn;
		  -webkit-animation-duration: 0.4s;
		  animation-name: slideIn;
		  animation-duration: 0.4s
		}

		/* The Close Button */
		.close {
		  color: white;
		  float: right;
		  font-size: 18px;
		  font-weight: bold;
		}

		.close:hover,
		.close:focus {
		  color: #000;
		  text-decoration: none;
		  cursor: pointer;
		}

		.modal-header {
		  padding: 2px 16px;
		  background-color: #4ca85c;
		  color: white;
		}

		.modal-body {padding: 2px 16px;}

		.modal-footer {
		  padding: 2px 16px;
		  margin-bottom: 20px;
		  background-color: darkgreen;
		  color: white;
		}

		/* Add Animation */
		@-webkit-keyframes slideIn {
		  from {bottom: -300px; opacity: 0}
		  to {bottom: 0; opacity: 1}
		}

		@keyframes slideIn {
		  from {bottom: -300px; opacity: 0}
		  to {top: 0; opacity: 1}
		}

		@-webkit-keyframes fadeIn {
		  from {opacity: 0}
		  to {opacity: 1}
		}

		@keyframes fadeIn {
		  from {opacity: 0}
		  to {opacity: 1}
		}

		#logout-control-top {
			visibility: hidden;
			display: none;
		}

	</style>
</head>
<script>
		var g_siteURL = window.location.host;
		var g_finalizers = []
		var g_loginStateViewHolders = {}
</script>
<body>
	<nav id="mainNav">
		<table style="width:100%">
			<tr>
				<td style="width:62;height:63">
					<a class="nav-link" href="/">
						<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   version="1.0"
   width="70"
   height="70"
   viewBox="0 0 350 350"
   preserveAspectRatio="xMidYMid meet"
   id="svg2">
  <defs id="defs16">
    <linearGradient id="linearGradient1115">
      <stop
         style="stop-color:#e9ff00;stop-opacity:1;"
         offset="0"
         id="stop1111" />
      <stop
         style="stop-color:#e9ff00;stop-opacity:0;"
         offset="1"
         id="stop1113" />
    </linearGradient>
    <filter
       style="color-interpolation-filters:sRGB"
       id="filter1107"
       x="-0.02418653"
       width="1.0483731"
       y="-0.023816325"
       height="1.0476327">
      <feGaussianBlur
         stdDeviation="2.8845338"
         id="feGaussianBlur1109" />
    </filter>
    <radialGradient
       xlink:href="#linearGradient1115"
       id="radialGradient1117"
       cx="162.94153"
       cy="166.10171"
       fx="162.94153"
       fy="166.10171"
       r="150.03728"
       gradientTransform="matrix(1,0,0,1.0148269,0,-2.4627807)"
       gradientUnits="userSpaceOnUse" />
  </defs>
  <g
     id="g4232"
     transform="translate(12.8,0)">
    <ellipse
       style="opacity:0.98000004;fill:url(#radialGradient1117);fill-opacity:1;stroke:none;stroke-width:33.07086563;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;paint-order:markers stroke fill;filter:url(#filter1107)"
       id="path833"
       cx="162.94153"
       cy="166.1017"
       rx="143.1144"
       ry="145.33899"
       transform="matrix(1.153994,0,0,1.1209987,-27.316594,-14.907414)" />
    <text
       transform="scale(1.0420353,0.95966038)"
       id="text4170"
       y="109.06458"
       x="144.01936"
       style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:95.65157318px;line-height:125%;font-family:sans-serif;text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ff0080;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       xml:space="preserve"><tspan
         y="109.06458"
         x="144.01936"
         id="tspan4172"
         style="fill:#ff0080;fill-opacity:1">O</tspan></text>
    <text
       id="text4195"
       y="243.96106"
       x="183.45763"
       style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:64px;line-height:125%;font-family:sans-serif;text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       xml:space="preserve"><tspan
         y="243.96106"
         x="183.45763"
         id="tspan4197">ong</tspan></text>
    <g
       id="g831"
       transform="translate(23.333334,11.666667)">
      <path
         style="fill:#0000ff;stroke:none"
         id="path12"
         d="m 65.085952,145.23192 c 3.26895,0.045 6.29859,-0.22234 6.72969,-0.55143 0.56359,-0.36425 0.98273,-2.72972 1.12104,-5.34268 0.13832,-2.61297 0.64228,-9.56307 1.1107,-15.43029 1.75701,-23.11592 2.87369,-37.52803 4.261,-58.18425 l 1.48023,-21.485981 11.992232,3.58025 c 10.950016,3.32009 12.621086,3.62804 18.522196,3.51118 14.2188,-0.23097 26.09194,-6.22644 32.52851,-16.25373 2.4006,-3.91106 2.85933,-5.48194 2.68708,-9.83735 -0.37617,-9.346466 -7.6659,-17.341296 -18.99565,-21.097346 -5.54917,-1.80138 -7.57621,-2.06853 -15.22352,-1.97132 -6.88593,0.10985 -10.92611,0.75264 -18.875886,2.86232 -13.283252,3.73975 -20.815682,7.93923 -25.381632,14.196096 -3.51988,4.79849 -3.5614,4.86318 -3.8692,20.24142 -0.38487,16.525811 -3.04833,67.255061 -3.6297,68.160751 -0.37373,0.58223 -7.0047,-2.27387 -12.57569,-5.41127 -8.70357,-4.93602 -17.27674,-12.64393 -20.88808,-18.66294 -7.03283,-11.82005 -7.01766,-25.88617 0.16639,-37.077941 2.45005,-3.81684 2.84156,-4.9405 1.77561,-5.6774 -1.85899,-1.38519 -5.75277,0.39953 -10.36429,4.84365 C 1.9240117,60.39223 -2.0878686,74.17718 4.8798417,89.18116 c 4.3155099,9.37451 7.2958803,12.609 21.4717203,24.08997 17.57938,14.22745 25.23493,21.48113 28.18573,26.81668 1.37651,2.47933 3.09315,4.60004 3.548,4.74769 0.58735,0.1125 3.77324,0.28681 7.00066,0.39642 z"
         />
      <ellipse
         style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2.25200582;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
         id="path4199"
         cx="110.36122"
         cy="26.560381"
         rx="21.172937"
         ry="11.617853" />
    </g>
    <path
       d="m 124.58334,69.729014 c -7.68174,3.748996 -12.93255,7.75361 -18.37783,14.229149 -6.612125,7.92402 -11.279516,16.444467 -13.418726,24.538887 -2.528168,9.3725 -2.333698,25.56135 0.38894,34.84864 l 1.94475,6.64594 -10.598858,8.94648 c -19.8364,16.78527 -31.21315,31.01442 -37.6308,46.69205 -3.50054,8.77605 -4.08397,23.60164 -1.26409,33.99658 2.72264,10.13934 8.65411,19.76744 16.04414,26.41339 7.48727,6.64595 15.26625,10.73577 26.93472,14.31436 8.654109,2.55613 9.918189,2.72654 22.947974,2.81174 l 13.80768,0 1.06961,4.26022 c 6.12594,24.53889 6.32042,27.09503 2.6254,33.31496 -1.94474,3.32297 -9.82095,8.00922 -13.51597,8.00922 -2.72264,0 -3.59777,-1.10766 -1.65303,-2.21532 2.23646,-1.19286 4.76462,-7.6684 4.76462,-12.52506 0,-13.97353 -15.46071,-22.57918 -30.143524,-16.70007 -15.36349,6.04951 -19.25298,21.72714 -8.65411,35.27464 13.807678,17.80774 37.047364,20.27867 55.230724,5.87912 12.34912,-9.71331 16.04414,-27.18023 10.40438,-48.82216 -1.36132,-5.28269 -2.52817,-9.96893 -2.52817,-10.39496 0,-0.34082 1.65304,-1.53368 3.59778,-2.55613 10.30714,-5.6235 20.71152,-15.3368 25.8651,-24.19807 4.66738,-8.09443 5.93147,-13.63272 5.93147,-25.13532 -0.0972,-9.79852 -0.29172,-11.16179 -3.01436,-17.29651 -5.34804,-11.67301 -13.22426,-18.74499 -25.96233,-23.17562 -7.39003,-2.55613 -15.46072,-3.749 -24.40654,-3.8342 l -5.93147,0 -2.33369,-10.13933 -2.33369,-10.13934 4.37567,-4.60104 c 12.25189,-12.69547 23.5314,-27.86186 27.12918,-36.29711 1.16685,-2.55613 2.72264,-8.43523 3.59778,-12.95108 1.55579,-7.6684 1.55579,-8.69085 0,-15.422007 C 146.75342,81.40203 137.32142,67.17288 132.07061,67.17288 c -1.26409,0 -4.57015,1.192862 -7.48727,2.556134 z m 4.66739,19.937843 c 1.16684,1.53369 2.52817,5.027068 3.11159,7.668411 2.52817,10.735762 -5.34805,26.328182 -19.35021,38.597622 -1.75027,1.53368 -3.59777,2.81176 -3.98672,2.81176 -2.52817,0 -2.91712,-21.55674 -0.58342,-28.79912 2.43093,-7.24239 6.90384,-13.973533 12.44636,-18.830192 2.72264,-2.385725 5.25081,-4.345432 5.63976,-4.345432 0.38894,0 1.65303,1.278071 2.72264,2.896951 z m -26.643,94.406573 1.26409,4.85665 -4.764625,2.72654 c -5.639751,3.15257 -12.543599,9.62811 -15.071759,14.14395 -1.45856,2.55613 -1.84751,5.11227 -1.84751,11.75821 0,10.30975 1.94474,14.48476 10.015428,21.64194 5.737001,5.11226 7.681741,4.94186 5.542521,-0.34082 -1.847501,-4.43063 -1.750271,-4.68624 0.58343,-10.13933 2.041975,-4.85666 8.751345,-12.86587 10.793325,-12.86587 0.68066,0 3.20882,9.4577 6.51489,24.02765 4.37567,19.25622 5.25081,24.19808 4.1812,24.5389 -2.62541,0.85204 -15.46072,0.34081 -21.392185,-0.85205 -13.029779,-2.72654 -22.850739,-9.20208 -28.490509,-18.9154 -3.20882,-5.53828 -3.30606,-5.96431 -3.20882,-16.01844 0,-9.37249 0.29171,-10.82097 3.11159,-17.29651 1.75027,-3.9194 4.47291,-8.86126 6.22319,-11.07658 4.86186,-6.30513 15.07176,-16.87048 20.030858,-20.70468 3.889491,-2.98217 4.667386,-3.23777 4.861856,-1.95971 0.19448,0.93725 0.97237,3.8342 1.65303,6.47555 z m 39.67278,26.24297 c 10.01544,3.32298 15.26624,10.99138 15.26624,22.57919 0,11.07658 -5.63975,20.10826 -15.46071,24.96491 l -3.88949,1.95971 -0.58342,-1.95971 c -0.29171,-1.10765 -2.43093,-10.22454 -4.86186,-20.27866 -2.52817,-10.05413 -4.86186,-19.68224 -5.25081,-21.30113 -0.48619,-1.61888 -1.16685,-4.0046 -1.45856,-5.36787 l -0.58342,-2.30053 5.73699,0 c 3.50054,0 7.97345,0.68164 11.08504,1.70409 z"
       id="path8"
       style="fill:#ff0000;stroke:none" />
    <g
       id="g827"
       transform="translate(-11.864407,57.641243)">
      <path
         d="m 234.35149,146.71497 c 3.26895,0.045 6.29859,-0.22234 6.72969,-0.55143 0.56359,-0.36425 0.98273,-2.72972 1.12104,-5.34268 0.13832,-2.61297 0.64228,-9.56307 1.1107,-15.43029 1.75701,-23.11592 2.87369,-37.528029 4.261,-58.184249 l 1.48023,-21.485981 11.99223,3.58025 c 10.95001,3.32009 12.62108,3.62804 18.52219,3.51118 14.2188,-0.23097 26.09194,-6.22644 32.52851,-16.25373 2.4006,-3.91106 2.85933,-5.48194 2.68708,-9.83735 -0.37617,-9.346466 -7.6659,-17.3412962 -18.99565,-21.0973462 -5.54917,-1.80138 -7.57621,-2.06853 -15.22352,-1.97132 -6.88593,0.10985 -10.92611,0.75264 -18.87588,2.86232 -13.28325,3.7397502 -20.81568,7.9392302 -25.38163,14.1960962 -3.51988,4.79849 -3.5614,4.86318 -3.8692,20.24142 -0.38487,16.525811 -3.04833,67.25506 -3.6297,68.16075 -0.37373,0.58223 -7.0047,-2.27387 -12.57569,-5.41127 -8.70357,-4.936019 -17.27674,-12.643929 -20.88808,-18.662939 -7.03283,-11.82005 -7.01766,-25.88617 0.16639,-37.077941 2.45005,-3.81684 2.84156,-4.9405 1.77561,-5.6774 -1.85899,-1.38519 -5.75277,0.39953 -10.36429,4.84365 -15.73297,14.748571 -19.74486,28.533521 -12.77714,43.537501 4.3155,9.374509 7.29588,12.608999 21.47172,24.089969 17.57938,14.22745 25.23493,21.48113 28.18573,26.81668 1.37651,2.47933 3.09315,4.60004 3.548,4.74769 0.58735,0.1125 3.77324,0.28681 7.00066,0.39642 z"
         id="path823"
         style="fill:#176431;fill-opacity:1;stroke:none" />
      <ellipse
         ry="11.617853"
         rx="21.172937"
         cy="26.560381"
         cx="278.33157"
         id="ellipse4230"
         style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2.25200582;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
    </g>
  </g>
</svg>

					</a>
				</td>
				<td>
                    <h1>Popsong Now Streams</h1>
				</td>
				<td>
					&nbsp;
				</td>
			</tr>
		</table>
	</nav>
	<main id='app-main'>
	
	</main>

<footer>
	<ul class="footer-list">
		<li>
			<a href="http://www.popsongnow.com">copyright &copy; 2020 popsongnow.com</a>
		</li>
	</ul>
</footer>


</body>
</html>
<script>



// MODULE: GLOBAL CRYPTO (windowized)

//$>>	setup_window_crypto
function setup_window_crypto() {
  if ( window.g_crypto === undefined ) {
    window.g_crypto = window.crypto ? window.crypto.subtle : null
    if ( g_crypto === null  ) {
      alert("No cryptography support in this browser. To claim ownership of assets, please use another browser.")
    }
  }
}



// MODULE: POST FETCH (windowized)

//$>>	fetchEndPoint
// //
// fetch with GET method
async function fetchEndPoint(endpoint,port) {
	port = !(port) ? '' : ( port.length ? `:${port}`   : '')
	let myRequest = new Request(`${location.protocol}//${g_siteURL}${port}/${endpoint}`);
	try {
		const body = await fetch(myRequest, {
									method: 'GET', // *GET, POST, PUT, DELETE, etc.
									mode: 'cors', // no-cors, *cors, same-origin
									cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
									credentials: 'omit', // include, *same-origin, omit
									redirect: 'follow', // manual, *follow, error
									referrerPolicy: 'no-referrer', // no-referrer, *client
								});
		//
		let infoObj = await body.json();
		return(infoObj)
		//
	} catch (e) {
		console.log(e.message)
		return(false)
	}
}


//$>>	fetchUrl
// //
// fetch with GET method
async function fetchUrl(endpoint) {
	let myRequest = new Request(endpoint);
	try {
		const body = await fetch(myRequest, {
									method: 'GET', // *GET, POST, PUT, DELETE, etc.
									mode: 'cors', // no-cors, *cors, same-origin
									cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
									credentials: 'omit', // include, *same-origin, omit
									redirect: 'follow', // manual, *follow, error
									referrerPolicy: 'no-referrer', // no-referrer, *client
								});
		//
		let infoObj = await body.json();
		return(infoObj)
		//
	} catch (e) {
		console.log(e.message)
		return(false)
	}
}


//$>>	postData
// //
//  call fetch with method POST tyr to help with parameters..  If data is FromData set do_stringify to false
//  default content type 'application/json'
//  User 'cors', Default cres = omit, If ctype == 'multipart/form-data' be sure to use FormData -- lets fetch set content type.
//  RETURNS: parsed JSON object or an empty object. ... Check for fields
//
async function postData(url = '', data = {}, creds = 'omit', do_stringify = true, ctype) {
	let content_type = 'application/json'
	if ( ctype !== undefined ) {
		content_type = ctype            // ctype is content type
	}
	let options = {
		method: 'POST', // *GET, POST, PUT, DELETE, etc.
		mode: 'cors', // no-cors, *cors, same-origin
		cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
		credentials: creds, // include, *same-origin, omit
		headers: {
			'Content-Type': content_type
		},
		redirect: 'follow', // manual, *follow, error
		referrerPolicy: 'no-referrer', // no-referrer, *client
		body: (do_stringify ? JSON.stringify(data)  : data)	// body data type must match "Content-Type" header
	}

	if ( ctype === 'multipart/form-data') {
		delete options.headers['Content-Type']  // content type will be set automatically with a boundary
	}

	// Default options are marked with *
	const response = await fetch(url, options);
	if ( response.ok == false ) {
		console.log(response.status + ': ' + response.statusText)
		return {}
	} else {
		return await response.json(); // parses JSON response into native JavaScript objects
	}
}


//$>>	post_submit
function hide_interface_box() {
	let display = document.getElementById('interface-box')
	if ( display ) {
		display.style.visibility = "hidden"
		display.style.display = "none"
	}
}

function hide_box(bxname) {
	let display = document.getElementById(bxname)
	if ( display ) {
		display.style.visibility = "hidden"
		display.style.display = "none"
	}
}

function show_box(bxname) {
	let display = document.getElementById(bxname)
	if ( display ) {
		display.style.visibility = "visible"
		display.style.display = "block"
	}
}

hide_box('error-box')
hide_box('success-box')

async function post_submit(fields) {
	let bdy = {}
	fields.forEach(element => {
		let fld = document.getElementById(element)
		if ( fld ) {
			bdy[element] = fld.value
		}
	});
	let url = bdy.post_url
	if ( url ) {
		delete bdy.post_url
		//
		let resp = await postData(url, bdy)
		//
		if ( resp ) hide_interface_box()
		if ( resp && (resp.OK === 'true') ) {
			show_box('success-box')
		} else {
			show_box('error-box')
		}
	}
}

//$$EXPORTABLE::
/*
fetchEndPoint
fetchUrl
postData
post_submit
*/


// MODULE: UPLOAD MEDIA (windowized)


const DEFINED_CHUNK_SIZE = 5000000
const DEFINED_MAX_SIZE = 9000000




// prep_upload_data
// 	-- if needed prepare the blob...  in any case separate the blob from the com object to send it later.
// 	-- return the com object and blob as a pair
//
async function prep_upload_data(obj,blob_already,protocol) {
	//
	let blob_data = ""
	//
	if ( !(blob_already) )  {
		try {
			let res = await fetch(obj.blob)
			blob_data = await res.blob()
		} catch(e) {
			return
		}
	} else {
		blob_data = blob_already
	}
	//
	if ( obj.blob !== undefined )  {
		delete obj.blob
	}
	obj.protocol = protocol ? protocol : 'p2p-default'
	obj.preamble_size = blob_data.size

	return [obj,blob_data]
}



//$>>	finalize_small_media_storage
async function finalize_small_media_storage(url,primary_response) {
	if ( primary_response.transition && primary_response.transition.token ) {
		let transaction_token = primary_response.transition.token
		let protocol = primary_response.elements.protocol
		let media_id = primary_response.elements.media_id
		let body = {
			"token" : transaction_token,
			"match" : "handshake",
		}
		body.protocol = protocol
		body.media_id = media_id   // maybe a checksum
		let secondary_resp =  await postData(url,body)
		return [protocol,media_id]
	}
	return [false,false]
}


//$>>	finalize_media_storage
//                                                  <<depends>> postData
//	There are likely faster ways of sending the data. But, this way requires some permission and safe guarding by the server sid.
async function finalize_media_storage(url,primary_response,formdata,blob,obj) {
	//
	let secondary_resp = primary_response
	//
	if ( primary_response.transition && primary_response.transition.token ) {	// A token has to be associated with the transaction
		//
		if ( formdata === false ) {
			formdata = new FormData()
			for ( let ky in obj ) {
				formdata.append(ky, obj[ky])
			}
		}
		let transaction_token = secondary_resp.transition.token		// call the transition token the transaction_token
		let protocol = obj.protocol ? obj.protocol : 'p2p-default'				// These fields have no real value until the end, but are always checked in case they may be used for security.
		let media_id = ""
		//
		formdata.set("protocol",protocol)				// Most likely ipfs ... 
		formdata.set("media_id",media_id)				// not set until the storage system can identify 
		formdata.set("token",transaction_token)
		formdata.set("match","upload-next")				// tell the server that you are sending one chunk after another
		formdata.set("next",true)  // NEXT
		formdata.set("_t_match_field",obj.file_name)
		//
		let size_end = blob.size						// total length of the data in flight
		let start = 0;
		let span = DEFINED_CHUNK_SIZE					// application generation sets this (tuning upstream)
		let num_sends = Math.floor(size_end/span) + 1	// size/chunk_size
		//
		for ( let i = 0; i < num_sends; i++ ) {			// the number of times this is called is determined by the client
			//
			let start = i*span
			let end = Math.min((i+1)*span,size_end)
			let blob_part = blob.slice(start,end)  				// next part of the blob
			formdata.set('media_file', new Blob([blob_part]),obj.file_name)
			secondary_resp = await postData(url,formdata, 'omit',false,'multipart/form-data')  // send it as a separate file
			//
			if ( (secondary_resp.OK !== "true") && (secondary_resp.OK !== true) ) {
				break;			// This last send failed. Bailout  (If failed, the server will shutdown the communication)
			}
		}
		//
		if ( (secondary_resp.OK === "true") || (secondary_resp.OK === true) ) {						// The last send was good.
			let body = {
				"token" : transaction_token,
				"match" : "complete",
				"_t_match_field" : obj.file_name,
				"file" : { "name" : obj.file_name },
				"next"	: false		// NO NEXT
			}
			secondary_resp =  await postData(url,body)			// Tell the server that this transaction is done...
			let elements = secondary_resp.state.elements			// The good stuff is returned in a state field 
			protocol = elements.protocol  // final hash and provider returned in state (same as for the shor but in the state field)
			media_id = elements.media_id
		}
		//
		return [protocol,media_id]
	}
	return [false,false]
}



//$>>	finalize_media_array_storage
//                                                  <<depends>> postData
//	There are likely faster ways of sending the data. But, this way requires some permission and safe guarding by the server sid.
async function finalize_media_array_storage(url,primary_response,formdata,blob_list,obj) {
	//
	let secondary_resp = primary_response
	//
	if ( primary_response.transition && primary_response.transition.token ) {	// A token has to be associated with the transaction
		//
		if ( formdata === false ) {
			formdata = new FormData()
			for ( let ky in obj ) {
				formdata.append(ky, obj[ky])
			}
		}
		let transaction_token = secondary_resp.transition.token		// call the transition token the transaction_token
		let protocol = obj.protocol ? obj.protocol : 'p2p-default'				// These fields have no real value until the end, but are always checked in case they may be used for security.
		let media_id = ""
		//
		formdata.set("protocol",protocol)				// Most likely ipfs ... 
		formdata.set("media_id",media_id)				// not set until the storage system can identify 
		formdata.set("token",transaction_token)
		formdata.set("match","upload-next")				// tell the server that you are sending one chunk after another
		formdata.set("next",true)  // NEXT
		formdata.set("_t_match_field",obj.file_name)
		//

		let max_num_sends = 0
		let blob_pars = blob_list.map( blob => {
			let blob_url = blob.blob_url
			let size_end = blob.size						// total length of the data in flight
			let start = 0;
			let span = DEFINED_CHUNK_SIZE					// application generation sets this (tuning upstream)
			let num_sends = Math.floor(size_end/span) + 1	// size/chunk_size
			max_num_sends = (num_sends > max_num_sends) ? max_num_sends : num_sends
			return {
				blob_str, size_end, start, span, num_sends
			}
		})
		// 
		let num_sends = Math.floor(size_end/span) + 1	// size/chunk_size
		//
		for ( let i = 0; i < max_num_sends; i++ ) {			// the number of times this is called is determined by the client
			//
			for ( let blob_dscr of blob_pars ) {
				if ( blob_dscr.num_sends === 0 ) continue
				let blob = blob_dscr.blob
				let span = blob_dscr.span
				let start = span*i
				let size_end = blob_dscr.size_end
				let end = Math.min((i+1)*span,size_end)

				let blob_part = blob.slice(start,end)  				// next part of the blob
				formdata.set('media_file', new Blob([blob_part]),blob_dscr.file_name)
				blob_dscr.num_sends--
			}
			//
			secondary_resp = await postData(url,formdata, 'omit',false,'multipart/form-data')  // send it as a separate file
			//
			if ( (secondary_resp.OK !== "true") && (secondary_resp.OK !== true) ) {
				break;			// This last send failed. Bailout  (If failed, the server will shutdown the communication)
			}
		}
		//
		if ( (secondary_resp.OK === "true") || (secondary_resp.OK === true) ) {						// The last send was good.
			let body = {
				"token" : transaction_token,
				"match" : "complete",
				"_t_match_field" : obj.file_name,
				"file" : { "name" : obj.file_name },
				"next"	: false		// NO NEXT
			}
			// postData
			secondary_resp =  await postData(url,body)			// Tell the server that this transaction is done...
			let elements = secondary_resp.state.elements			// The good stuff is returned in a state field 
			protocol = elements.protocol  // final hash and provider returned in state (same as for the shor but in the state field)
			media_id = elements.media_id
		}
		//
		return [protocol,media_id]
	}
	return [false,false]
}




//$>>	upload_small
//                                                  <<depends>> postData,finalize_small_media_storage
async function upload_small(url,obj,blob_already) {			// 	obj.media_type  // data:[<MIME-type>][;charset=<encoding>][;base64],<data>
	//
	let [com_obj,blob_data] = await prep_upload_data(obj,blob_already,'p2p-default')
	//
	let formdata = new FormData()
	for ( let ky in com_obj ) {
		formdata.append(ky, com_obj[ky])
	}
	formdata.append('media_file', new Blob([blob_data]), obj.file_name)
	//
	// in the small versions, the file is sent immediately. No preamble
	//
	let primary_response =  await postData(url,formdata,'omit',false,'multipart/form-data')
	if ( primary_response.OK === "true" ) {
		let media_store_characteristics = await finalize_small_media_storage(primary_response)
		return media_store_characteristics
	} else {
		return [false, false]
	}
}

//$>>	upload_big
//                                                  <<depends>> postData,finalize_media_storage
async function upload_big(url,obj,blob_already) {
	//
	let [com_obj,blob_data] = await prep_upload_data(obj,blob_already,'p2p-default')
	//
	let formdata = new FormData()
	for ( let ky in com_obj ) {
		formdata.append(ky, com_obj[ky])
	}
	//
	// in the large versions, a preamble is sent with the size of the data. No data is sent in the first message
	//
	let primary_response = await postData(url,formdata,'omit',false,'multipart/form-data')
	//
	if ( primary_response.OK === "true" ) {		// If the system can handle the request, start a cycle of sends
		let media_store_characteristics = await finalize_media_storage(primary_response,formdata,blob_data,obj)
		return media_store_characteristics
	} else {
		return [false, false]
	}
}






//$>>	upload_audio
//                                                  <<depends>> upload_big,upload_small
// ---- ---- ---- ---- ---- ---- ----
async function upload_audio(obj) {
	let blob_data
	try {
		let res = await fetch(obj.blob)
		blob_data = await res.blob()
	} catch(e) {
		return
	}
	if ( blob_data.size > DEFINED_MAX_SIZE ) {
		return await upload_big(obj,blob_data)
	} else {
		return await upload_small(obj,blob_data)
	}
}

//$>>	upload_image
// ---- ---- ---- ---- ---- ---- ----
async function upload_image(obj) {
	let blob_data
	try {
		let res = await fetch(obj.blob)
		blob_data = await res.blob()
	} catch(e) {
		return
	}
	if ( blob_data.size > DEFINED_MAX_SIZE ) {
		return await upload_big(obj,blob_data)
	} else {
		return await upload_small(obj,blob_data)
	}
}

//$>>	upload_video
//                                                  <<depends>> upload_big
// ---- ---- ---- ---- ---- ---- ----
async function upload_video(obj) {
	return await upload_big(obj)
}

//$>>	prep_upload_for
//
// ---- ---- ---- ---- ---- ---- ----
var g_uploader_cache = {}
function prep_upload_for(obj,uploader_fun) {
	//
	g_uploader_cache[obj._dash_entry_id] = async () => {
		return await uploader_fun(obj)
	}
	//
}

//$>>	do_media_upload
//                                                  <<depends>> prep_upload_for
//                                                  <<var-depends>> g_uploader_cache
async function do_media_upload(obj) {		// earlier a link was made for the media, which will be uploaded if ever the user "save"s it.
	let id = obj._dash_entry_id
	let _uploader = g_uploader_cache[id]	// _uploader from map
	if ( _uploader ) {
		let [protocol,asset_id] = await _uploader()
		return [protocol,asset_id]
	}
}


//$$EXPORTABLE::
/*
finalize_small_media_storage
finalize_media_storage
upload_small
upload_big
upload_audio
upload_image
upload_video
prep_upload_for
do_media_upload
*/


	//
	// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
	let g_punctuation = ".,;:\'\"~\~\`@#$%^&*()+=|\\][}{?/><"

	function ispunct(c,add_dash) {
		let is = (g_punctuation.indexOf(c) >= 0 )
		if ( !(is) && add_dash ) {
			is = (c == '-' || c == '_')
		}
		return is
	}

	function trim_punct(key,add_dash) {
		while ( (key.length > 0) && ispunct(key[0],add_dash) ) {
			key = key.substr(1)
		}
		while ( (key.length > 0) && ispunct(key[key.length - 1],add_dash) ) {
			key = key.substr(0,(key.length - 1))
		}
		return(key)
	}



	class DataFromUi {

		constructor() {
			this._user_id = false
			this._current_asset_history = false
			this._current_asset_prev_text = ""
			this._current_asset_text_ucwid_info = false
		}

		get_file(file_el) {
			//
			if ( file_el.files.length ) {
				return new Promise((resolve,reject) => {
					let file = file_el.files[0]
					let fname =  file.name
					let mtype = file.type
					let reader = new FileReader();
					let file_copy = Object.assign({},file)
					for ( let ky in file ) { 
						if ( ky === 'arrayBuffer' ) continue
						if ( ky === 'slice' ) continue
						if ( ky == 'stream' ) continue
						if ( ky == 'text' ) continue
						if ( ky == 'webkitRelativePath' ) continue
						file_copy[ky] = file[ky]
					}
					reader.onload = (e) => {
						//
						let loaded = {
							"blob_url" : e.target.result,
							"name" : fname,
							"mtype" : mtype,
							"size" : file_copy.size,
							"file" : file_copy
						}
						//
						resolve(loaded)
					};
					reader.readAsDataURL(file)
				})
			}
			//
			return false
		}

		async gather_user_fields(field_vars) {
			let upload_record = {}
			try {
				let tracking = ""
				let t = field_vars['user-tracking']
				if ( t.length ) { tracking = t }
				//
				let uid = field_vars['user-id']
				if ( uid.length ) {
					upload_record = {
						"_id" : uid,
						"_tracking" : tracking
					}
					this._user_id = uid
					this._author_tracking = tracking
					return upload_record
				}

			} catch (e) {
				return false
			}
			return false
		}

		//  ----  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
		async gather_fields(field_vars) {
			//
			if ( this._user_id === false ) {
				return false
			}
			//
			let upload_record = {}
			try {
				let opt_fld = field_vars['rec-file-mtype']
				let title_fld = field_vars['rec-title']
				let subject_fld = field_vars['rec-subject']
				let keys_fld = field_vars['rec-keys']
				let abstract_fld = field_vars['rec-abstract']
				let full_text_fld = field_vars['rec-full-text']
				let file_name_fld = field_vars['rec-file-name']
				let poster_name_fld = field_vars['rec-poster-name']
				let paid_fld = field_vars['paid-checkbox']

				if ( !(opt_fld && title_fld && keys_fld && abstract_fld && full_text_fld && file_name_fld && poster_name_fld) ) return false

				let full_text = full_text_fld.value
				//
				let title = title_fld.value
				if ( title.length === 0 ) return false
				//
				let subject = subject_fld.value
				if ( subject.length === 0 ) return false
				//
				let abstract =  abstract_fld.value

				let asset_pair = opt_fld.value
				if ( asset_pair.length === 0 ) return false
				//
				let [asset_type,media_type] = asset_pair.split('/')
				/*
					stream/audio
					stream/video
					stream/image
					blog/text
					music_buzz/text
				*/
				let poster = await this.get_file(poster_name_fld)        // file names for stream type media
				let media_data = await this.get_file(file_name_fld)

				if ( (media_type !== 'text') && (media_data === false) && (poster === false) ) {
					return false
				}

				if ( ( media_type === 'text' ) && ( full_text.length === 0 ) ) {
					return false
				} else if ( media_type !== 'text' ) {
					full_text = file_name_fld.files[0].name
				}

				//
				let modDate = media_data ? media_data.file.lastModified : ( poster ? poster.file.lastModified : Date.now())
				//
				let keys = keys_fld.value
				keys = keys.split(' ').filter( key => {
					let ok = (key !== undefined)
					if ( ok ) ok = (key.length > 2)
					return ok
				})
				keys = keys.map(key => {
					key = trim_punct(key)
					key = key.trim()
					return(key)
				})
				keys = keys.filter( key => {
					let ok = (key !== undefined)
					if ( ok ) ok = (key.length > 2)
					return ok
				})
				keys = keys.map(key => {
					key = encodeURIComponent(key)
					return(key)
				})
				//
				let tracking = ""       // if it has been created
				let tracker = field_vars["asset-id"]
				if ( tracker ) {
					let t = tracker.value
					if ( t.length ) tracking = t
				}


				let paid = paid_fld ? paid_fld.checked : false

				let exclusion_fields = [
					"_history","_prev_text",
					"_transition_path", "encode",
					"media.poster.ucwid_info", "media.source.ucwid_info",
					"media.poster.protocol", "media.source.protocol",
					"media.poster.ipfs", "media.source.ipfs"
				]
				let repository_fields = [ "media.source", "media.poster" ]  // field that contain id's useful to pin object at the server
				//
				upload_record = {
					"_tracking" : tracking,             // tracking of the asset
					"_id" :  this._user_id,             // should be a UCWID
					"_author_tracking" :  this._author_tracking,
					"_paid" : paid,
					"_transition_path" : "asset_path",
					"asset_path" : `${tracking}+${asset_type}+${this._user_id}`,
					"title" : encodeURIComponent(title),
					"subject" : encodeURIComponent(subject),
					"keys" : keys,
					"asset_type" : asset_type,        // blog, stream, link-package, contact, ownership, etc...
					"media_type" : media_type,        // text, audio, video, image
					"abstract" : encodeURIComponent(abstract),
					"media" : {
						"poster" : poster,
						"source" : media_data
					},
					"encode" : true,
					"txt_full" : encodeURIComponent(full_text),
					"dates" : {
						"created" : Date.now(),
						"updated" : modDate
					},
					"_history" : this._current_asset_history ? this._current_asset_history : [],
					"_prev_text" : this._current_asset_prev_text,
					"text_ucwid_info" : this._current_asset_text_ucwid_info,
					"repository_fields" : repository_fields,
					"exclusion_fields" : exclusion_fields
				}
				this._current_asset_history = false   // reset it when it is retrieved
				//    
			} catch (e) {
				return false
			}

			return(upload_record)
		}



		//  ----  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
		async gather_identifying_fields(field_vars) {
			//
			if ( this._user_id === false ) {
				return false
			}
			//
			let upload_record = {}
			try {
				let tracker = field_vars["asset-id"]
				let opt_fld = field_vars['rec-file-mtype']
				if ( !(opt_fld && tracker) ) return false

				let asset_pair = opt_fld.value
				if ( asset_pair.length === 0 ) return false
				//
				let [asset_type,media_type] = asset_pair.split('/')
				/*
					stream/audio
					stream/video
					stream/image
					blog/text
					music_buzz/text
				*/
				//
				//
				let tracking = ""       // if it has been created
				if ( tracker ) {
					let t = tracker.value
					if ( t.length ) tracking = t
					else return false
				}

				let paid_fld = field_vars['paid-checkbox']
				let paid = paid_fld ? paid_fld.checked : false

				//
				let exclusion_fields = [  // fields excluded from searching services.
					"_history","_prev_text",
					"_transition_path", "encode",
					"media.poster.ucwid_info", "media.source.ucwid_info",
					"media.poster.protocol", "media.source.protocol",
					"media.poster.ipfs", "media.source.ipfs"
				]

				//
				upload_record = {
					"_tracking" : tracking,
					"_id" :  this._user_id,
					"_paid" : paid,
					"_transition_path" : "asset_path",
					"asset_path" : `${tracking}+${asset_type}+${this._user_id}`,
					"asset_type" : asset_type,        // blog, stream, link-package, contact, ownership, etc...
					"media_type" : media_type,
					"exclusion_fields" : exclusion_fields
				}
				//
			} catch (e) {
				return false
			}

			return(upload_record)
		}

		// put_fields ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
		put_fields(obj,field_vars) {
			let opt_fld = field_vars['rec-file-mtype']
			let title_fld = field_vars['rec-title']
			let subject_fld = field_vars['rec-subject']
			let keys_fld = field_vars['rec-keys']
			let abstract_fld = field_vars['rec-abstract']
			let full_text_fld = field_vars['rec-full-text']
			let file_name_fld = field_vars['rec-file-name']
			let poster_name_fld = field_vars['rec-poster-name']
			let paid_fld = field_vars['paid-checkbox']
			if ( !(opt_fld && title_fld && keys_fld && abstract_fld && full_text_fld && file_name_fld  && poster_name_fld) ) return false
			
			title_fld.value = decodeURIComponent(obj.title)
			subject_fld.value = decodeURIComponent(obj.subject)
			keys_fld.value = decodeURIComponent(obj.keys)
			opt_fld.value = [obj.asset_type,obj.media_type].join('/')
			abstract_fld.value = decodeURIComponent(obj.abstract)
			full_text_fld.value = decodeURIComponent(obj.txt_full)

			if ( paid_fld )  {
				paid_fld.setAttribute("checked",obj._paid)
			}

			this._current_asset_history = obj._history
			this._current_asset_prev_text = obj.txt_full
			this._current_asset_text_ucwid_info = obj.text_ucwid_info ? obj.text_ucwid_info : false
		}

		async gather_asset_fields(field_vars) {
			//
			let upload_record = {}
			try {
				let asset_fld = field_vars['asset-id']
				upload_record._id = asset_fld.value
			} catch (e) {
				return false
			}
			return upload_record
		}

	}




	class Proxy {


		constructor() {

			//
			this.new_entry_link = ""
			this.get_entry_link = ""
			this.update_entry_link = ""

			this.delete_entry_link = ""
			this.publish_entry_link = ""
			this.unpublish_entry_link = ""
			this.get_user_ready_link = ""

		}


		async new_entry(good_data) {
			// to transitions 
			let uploadable = {
				"meta" : good_data		// good data already has urls for BLOBs representing the media to upload
				// file entries, etc/	
			}
			let [result,pid] = await send_new_entry(uploadable,this.new_entry_link,good_data.asset_type)
			if ( result.status === "OK" ) {
				return status.tracker
			}
		}


		async get_entry(good_data) {
			let uploadable = {
				"meta" : good_data
				// file entries, etc/	
			}
			let result = await send_publication_command("get",uploadable,this.get_entry_link)
			if ( result.status === "OK" ) {
				return status.tracker
			}
		}

		async update_entry(good_data) {
			good_data.update = true   // something better?
			let uploadable = {
				"meta" : good_data
				// file entries, etc/	
			}
			let [result,pid] = await send_new_entry(uploadable,this.update_entry_link,good_data.asset_type)
			if ( result.status === "OK" ) {
				return status.tracker
			}
		}

		async delete_entry(good_data) {
			let uploadable = {
				"meta" : good_data
				// file entries, etc/	
			}
			let result = await send_publication_command("get",uploadable,this.delete_entry_link)
			if ( result.status === "OK" ) {
				return status.tracker
			}
		}

		async publish_entry(good_data) {
			let uploadable = {
				"meta" : good_data
				// file entries, etc/	
			}
			let result = await send_publication_command("publish",uploadable,this.publish_entry_link)
			if ( result.status === "OK" ) {
				return status.tracker
			}
		}

		async unpublish_entry(good_data) {
			let uploadable = {
				"meta" : good_data
				// file entries, etc/	
			}
			let result = await send_publication_command("unpublish",uploadable,this.unpublish_entry_link)
			if ( result.status === "OK" ) {
				return status.tracker
			}
		}

	}



	let g_ui_data = new DataFromUi()
	let g_proxy = new Proxy()

	///

	// field_data :: in the following, field_data is a map of fields ids to DOM element objects. 
	// values will be read in from those fields
	// calculation on values will be handled by gather_fields
	// FILES: two fields will refer to the DOM element for file uploaders. 
	//		-- rec-file-name	--- likely a media file e.g. mp3, mov, etc.
	//		-- rec-poster-name   --- likely an image file that will be displayed

	//
	// ---- create_entry ---- ---- ---- ---- ---- ---- ----
    async function create_entry(field_data) {
        if ( field_data ) {
			let good_data = g_ui_data.gather_fields(field_data)  // puts the upload file into the structure
			let t_num = await g_proxy.new_entry(good_data)
			return t_num /// for placement into display
        }
    }

	// ---- get_entry ---- ---- ----
	async function get_entry(field_data) {
		let good_data = await g_ui_data.gather_identifying_fields(field_data)
		if ( good_data ) {
          let obj = await g_proxy.get_entry(good_data)
          let t_num = obj._tracking
          if ( t_num !== false ) {
			field_data["asset-id"] = t_num
          }
          g_ui_data.put_fields(obj)
        }
    }
  
	// ---- update_entry ---- ---- ----
    async function update_entry(field_data) {
        let good_data = await g_ui_data.gather_fields(field_data)
        if ( good_data ) {
          let t_num = await g_proxy.update_entry(good_data)
          if ( t_num !== false ) {
			field_data["asset-id"] = t_num
          }
        }
    }

	// ---- delete_entry ---- ---- ----
    async function delete_entry(field_data)  {
      let good_data = await g_ui_data.gather_identifying_fields(field_data)
        if ( good_data ) {
          await g_proxy.delete_entry(good_data)
        }
    }

	// ---- publish_entry ---- ---- ----
    async function publish_entry(field_data) {
        let good_data = await g_ui_data.gather_identifying_fields(field_data)
        if ( good_data ) {
          await g_proxy.publish_entry(good_data)
        }
    }

	// ---- unpublish_entry ---- ---- ----
    async function unpublish_entry(field_data) {
        let good_data = await g_ui_data.gather_identifying_fields(field_data)
        if ( good_data ) {
          await g_proxy.unpublish_entry(good_data)
        }
    }

	// ---- get_user_tracking ---- ---- ----
    async function get_user_tracking(field_data) {
		let good_data = await g_ui_data.gather_user_fields(field_data)
		if ( good_data ) {
			let t_num = await g_proxy.user_ready(good_data)
			field_data["user-tracking"] = t_num
		}
    }






	let g_app_path = "command-upload"


	// g_app_path important to nginx configuration

	function get_transition_endpoint(endpoint) {
		let url = `${location.protocol}//${location.host}/${g_app_path}/transition/${endpoint}`
		return url
	}

	function get_secondary_transition_endpoint(endpoint) {
		let url = `${location.protocol}//${location.host}/${g_app_path}/transition/secondary/${endpoint}`
		return url
	}


	// prep_send_new_entry
	async function prep_send_new_entry(data_hash,send_obj) {
		// send the fields this knows about. Expect the human frame to handle a hash and security
		let postable = Object.assign(send_obj,{
			"topic" : "command-upload",
			"path" : "upload-media"
		})
		//
		//
		let message = {
			"category": FRAME_ACTION_FROM_APP,
			"action" : HOST_UP_REQ_UPLOAD,
			"data" : {
				"link" : get_transition_endpoint(link_meta.link),
				"hash" : data_hash,
				"postable" : postable
			}
		}
		tell_frame_page(message)  // ask for the primary transition to be handled by the human frame...
		//
		let primary_response = await promise_handling("post-response")
		return primary_response
	}



	async function send_new_entry(object_data_meta,link_meta,asset_type) {
		//
		/*
		object_data_meta === { "meta" : good_data }
		*/
		if ( object_data_meta.meta.media && object_data_meta.meta.media.source ) {
			let blob_data = object_data_meta.meta.media.source.blob_url
			let blob_data_size = object_data_meta.meta.media.source.size
			if ( object_data_meta.meta.media.poster ) {
				blob_data_size += object_data_meta.meta.media.poster.size
			}
			//
			let com_obj = {
				protocol : 'p2p-default',
				preamble_size : blob_data_size  // send total size
			}
			com_obj = Object.assign(object_data_meta,com_obj)
			//
			// +  obj.protocol,  + obj.preamble_size    // { "meta" : good_data, "protocol" : - ,  "preamble_size" : - }
			let data_hash = do_hash(blob_data)  // the file data of the main type of media (e.g. movie, sound, which might also upload an image)
			//   post data in here  (prep --- don't send the actual file... )

			let backup_media = {
				"source" : com_obj.meta.media.source,
				"poster" : com_obj.meta.media.poster
			}


			// make copies of the media components
			com_obj.meta.media.source = Object.assign({},com_obj.meta.media.source)
			delete com_obj.meta.media.source.blob_url  // (prep --- don't send the actual file... )
			//
			if ( object_data_meta.meta.media.poster ) {
				com_obj.meta.media.poster = Object.assign({},com_obj.meta.media.poster)
				delete com_obj.meta.media.poster.blob_url   // (prep --- don't send the actual file... )
			}

			let primary_response = await prep_send_new_entry(data_hash,com_obj)
			//
			if ( primary_response.OK == true ) {
				let upload_keys = primary_response.elements  // should be produced by publication handling
				let postable = Object.assign(com_obj,{
					"token" : primary_response.token,		// primary action token (key to secondary)
					"asset_type" : asset_type,
					"sign" : upload_keys.sign,
					"hash" : data_hash
				})
				// --- backup_media
				let blob_list = [backup_media.source,backup_media.poster]
				let link = get_secondary_transition_endpoint(link_meta.secondary_link)
				//  , primary_response -> original respone, false -> will make FromData, blob_data -> one file, 
				let media_store_characteristics = await finalize_media_array_storage(link,primary_response,false,blob_list,postable)
				
				
				
				
				//return media_store_characteristics
			}
		}

		return [false,false]
		//
	}



	async function send_publication_command(command,object_data_meta,link_meta) {
		//
		let postable = Object.assign(object_data_meta,{
			"topic" : `command-${command}`,
			"path" : "upload-media",
			"file_name" : data_hash
		})
		//
		let message = {
			"category": FRAME_ACTION_FROM_APP,
			"action" : HOST_UP_REQ_UPLOAD,
			"data" : {
				"link" : get_transition_endpoint(link_meta.link),
				"hash" : data_hash,
				"postable" : postable
			}
		}
		tell_frame_page(message)  // ask for the primary transition to be handled by the human frame...
		//
		let primary_response = await promise_handling("post-response")
		if ( primary_response.OK == true ) {
			return true
		} 
		return false
		//
	}


// /////////////////////////////////////////////////////


setup_window_crypto()

</script>
