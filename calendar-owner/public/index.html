<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="author" content="Richard Leddy" />
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
	<meta id="theme-color" name="theme-color" content="#452770">

	<title>Copious Training Calendars</title>

	<link rel='icon' type='image/png' href='./favicon.png'>
	<link rel='stylesheet' href='./global.css'>
	<link rel='stylesheet' href='./build/bundle.css'>
	
	<script defer src='./build/bundle.js'></script>

	<link rel="canonical" href="http://www.copious.world">

	<meta name="description" content="Copious World Admin Pages.">

<style>
	/*csslint important:false*/

	/* ==========================================================================
	Pure Base Extras
	========================================================================== */

	/**
	* Extra rules that Pure adds on top of Normalize.css

	html {
	}
	*/

	/**
	* Always hide an element when it has the `hidden` HTML attribute.
	*/

	.hidden,
	[hidden] {
		display: none !important;
	}

	/**
	* Add this class to an image to make it fit within it's fluid parent wrapper while maintaining
	* aspect ratio.
	*/
	.pure-img {
		max-width: 100%;
		height: auto;
		display: block;
	}

	.items {
		display: flex;
		flex-wrap: wrap;
		margin-left: -10px;
		margin-top: -10px;
	}

	.items .item {
		flex: 1 0 300px;
		box-sizing: border-box;
		background: -webkit-linear-gradient(to right, rgba(242, 242, 210, 0.3), white));
		background: linear-gradient(to right, rgba(242, 242, 210, 0.3), white );
		color: #171e42;
		padding: 10px;
		margin-left: 10px;
		margin-top: 0px;
	}

	.items .extra-i {
		padding-left: 10%;
		padding-bottom: 4px;
		padding-right: 12px;
		font-size: 110%;
		font-family: sans-serif;
	}

	.middleBanner {
		text-align: 'center';
		padding-left: 10%;
		padding-right: 10%;
		font-weight:bold;
		color: darkgreen;
		padding-top:4%;
		overflow:auto;
	}

	.applink {
		padding:3px;
		background-color: cornsilk;
		width:inherit;
		min-height: 100%;
		color:darkolivegreen;
		font-weight: bolder;

	}

	.extraBanner {
		text-align: 'center';
		padding-left: 10%;
		padding-right: 10%;
		font-weight:bold;
		color: #FF4400;
		padding-top:4%;
	}


	.fillLowerWrap {
		width: 66%;
		margin-left:0px;
		margin-right:0px;
		padding: 8px;
		margin-top:8px;
		background: -webkit-linear-gradient(to right, white, #FAFAFF);
		background: linear-gradient(to right, white, #FAFAFF );
		margin-left: 10px;
	}

	.fitMenuLower {
		width: 95%;
		height: 50%;
		margin-left:0px;
		margin-right:0px;
		padding: 8px;
		margin-top:8px;
		background: -webkit-linear-gradient(to right, white, #FAFAFF);
		background: linear-gradient(to right, white, #FAFAFF );
		margin-left: 10px;
	}

	#squashMenu:hover {
		border: 1px solid rgb(230,230,240,0.4);
		padding-top:4px;
		background-color: #EFEFEF;
	}

	#squashMenuContainer {
		position:absolute;
		visibility:hidden;
		top : 0; left : 0;
		height:100%;
		width: 55%;
		z-index:100;
		border: rgba(252, 190, 190, 0.4) 2px solid;
		background-color: white;
	}

	.fade_able {
		position:absolute;
		visibility:hidden;
		top : 10px; left : 10px;
		height:80%;
		width: 40%;
		z-index:101;
		border: rgba(252, 190, 190, 0.4) 2px solid;
		background-color: white;
		overflow:hidden;
	}

	.solid_able {
		position:absolute;
		visibility:hidden;
		top : 10px; left : 10px;
		height:80%;
		width: 40%;
		z-index:111;
		border: rgba(252, 190, 190, 0.4) 2px solid;
		background-color: white;
		overflow: hidden;
	}

	@media screen and (max-width: 950px) {
		.solid_able {
			width: 90%;
		}
	}

	#thankyou_box {
		position:absolute;
		visibility:hidden;
		top : 25%; left : 25%;
		height:50%;
		width: 50%;
		z-index:150;
		border: rgba(100, 5, 5, 0.6) 2px solid;
		background-color: lightgoldenrodyellow;
		overflow: auto;
	}

	@media screen and (max-width: 1040px) {
		.fade_able {
			width: 60%;
		}
	}

	@media screen and (max-width: 600px) {
		.fade_able {
			width: 90%;
		}
	}

	.fade_able_content {
		height:100%;
		width: 100%;
		overflow:auto;
	}

	.togglebar {
		height:20px;
		visibility:inherit;
		background-color: navy;
		text-align:right;
	}

	.closer_x {
		padding:2px;
		color:purple;
		font-weight:bolder;
		border: solid 1px red;
		cursor:pointer;
	}

	@media (max-width: 1225px) {
		.fillLowerWrap {
			visibility : "none";
			height : 0px;
		}
	}


	.fillLower {
		border: darkred 2px solid;
		height: 96%;
		width: 96%;
		margin-left: 10px;
		padding:8px;
		background: -webkit-linear-gradient(to right, rgba(252, 252, 240, 0.4), #FEFEFE);
		background: linear-gradient(to right, rgba(252, 252, 240, 0.4), #FEFEFE );
	}

	button {
		cursor: pointer;
		font-size: 101%;
		font-weight: bold;
		color: darkblue;
		margin: 2px;
		width:120px;
	}

	button:hover {
		background-color : #CACAFF;
		color: darkred;
	}

	@media screen and (max-width: 390px) {
		.items .extra-i {
			padding-left: 1%;
		}
	}

	@media screen and (max-width: 600px) {
		.items .extra-i {
			padding-left: 3%;
		}
	}

	.longviz {
		visibility : "visibile";
		height: 10px;
		background-color:inherit;
	}

	@media (max-width: 1040px) {
		.longviz {
			visibility : "none";
			height : 0px;
		}
	}

	.shortviz {
		visibility : "none";
		height:0px;
		margin-top:6px;
	}

	@media (max-width: 620px) {
		.shortviz {
			visibility : "visible";
			height:2px;
			background-color:darkgreen;
			margin-bottom:12px;
		}
	}

	@media (min-width: 1040px) {
		.shortviz {
			visibility : "visible";
			height:120px;
			border: 2px darkblue solid;
			background-color:#FFFFF6;
			margin-bottom:30px;
			margin-top:5px;
		}
	}

	@media (min-width: 380px) {
		.items .item {
			max-width: calc(100% - 20px);
		}
		.items .extra-i {
			padding-left: 3%;
		}
	}
	@media (min-width: 410px) {
		.items .item {
			max-width: calc(100% - 10px);
		}
	}
	@media (min-width: 620px) {
		.items .item {
			max-width: calc(50% - 10px);
		}
	}
	@media (min-width: 830px) {
		.items .item {
			max-width: calc(50% - 10px);
		}
	}
	@media (min-width: 1040px) {
		.items .item {
			max-width: calc(33.33333% - 10px);
		}
	}
	@media (min-width: 1250px) {
		.items .item {
			max-width: calc(25%- 10px);
		}
	}
	@media (min-width: 1460px) {
		.items .item {
			max-width: calc(20% - 10px);
		}
	}
	@media (min-width: 1670px) {
		.items .item {
			min-width: calc(16.66667% - 10px);
		}
	}


	body {
		border: 1px solid black;
		
		-moz-box-sizing: border-box;
		box-sizing: border-box;
	}


	@media screen and (orientation: portrait) {
		#mainNav {
			width: 100%;
		}
	}

	@media screen and (orientation: landscape) {
		#mainNav {
			width: 100%;
		}
	}

	main {
		border-left: solid 3px navy;
		border-top: solid 1px #8833BB;
		padding : 4px;
	}

	#mainNav {
		font-family: 'Montserrat', 'Helvetica Neue', Helvetica, Arial, sans-serif;
		font-weight: 700;
		text-transform: uppercase;
		background: blue;
		border-left: solid 3px navy;
		border-top: solid 3px navy;
		border-bottom: solid 3px rgba(252,252,255,0.7);
		min-height: 90px
		padding: 20px
		background: -webkit-linear-gradient(to left, rgba(242, 242, 210, 0.3), white);
		background: linear-gradient(to left, rgba(242, 242, 210, 0.3), white );
		
	}

	#mainNav table {
		padding-left: 3%;
	}


	#mainNav  table  a:focus { outline: none; }
	#mainNav  table  .navbar-brand {
		font-size: 1.1rem;
		color: white;
	}

	#mainNav  table  .navbar-brand.active, #mainNav .navbar-brand:active, #mainNav .navbar-brand:focus, #mainNav .navbar-brand:hover {
		color: white;
	}

	#mainNav  table  .navbar-nav {
		letter-spacing: 1px; }

	#mainNav  table  .navbar-nav li.nav-item {
		display:inline;
	}

	
	
	#mainNav  table  .navbar-nav li.nav-item a.nav-link {
		color: darkgreen;
		text-decoration: none;
		vertical-align: top;
		padding-right: 10px;
	}

	#mainNav  table  .navbar-nav li.nav-item a.nav-link:hover {
		color: #18BC9C;
		outline: none;
		
	}


	#mainNav  table  .navbar-nav a.nav-text {
		background-color : rgba(242,222,255,0.6);
		border-radius: 25px;
		margin-bottom: 9px;
		margin-right: 6px;
		white-space: nowrap;
	}


	#mainNav  table  .navbar-nav li.nav-item a.nav-link:active, #mainNav .navbar-nav li.nav-item a.nav-link:focus { color: white; }
	
	.footer-list li {
		list-style-type: none;
	}

	.footer-list li a:hover { color: gold; }
	
	.hover_group {
		cursor:pointer;
	}

	.hover_group rect {
		fill:#e6e6e6;
	}

	.hover_group:hover rect {
		fill: #F6F6e6;
	}

	footer {
		padding:10px;
		background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2 );
		background: linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2  );
		text-align: center;
		font-size: 0.85em;
	}

	footer a {
		text-decoration:none;
		color:darkgreen;
		font-weight:bold;
		font-style: italic;
	}

	.copiouslink:hover {
		fill:navy;
	}
	.copiouslink {
		fill:black;
	}

	* {margin: 0; padding: 0; box-sizing: border-box}
	
	.PhIOtjDr_0 {
		fill:none;
		stroke:#1c1448;
		stroke-width:4.59875107;
		stroke-miterlimit:4;
		stroke-dasharray: 2948 2950;
		stroke-dashoffset: 2949;
		animation: PhIOtjDr_draw 6666ms ease-in forwards;
	}

	@keyframes PhIOtjDr_draw {
		100% {stroke-dashoffset: 0}
	}

	@keyframes PhIOtjDr_fade {
		0% {stroke-opacity: 1}
		97.1830985915493% {stroke-opacity: 1}
		100% {stroke-opacity: 0}
	}

	.form_el {
		border:lightgray solid 1px;
		padding:6px;
		margin:2px;
		width:80%;
	}

	.form_el_inner {
		border:lightgray solid 1px;
		padding:6px;
		margin:2px;
		width:100%;
	}

	label {
		font-weight:bold;
		color:darkgreen;
		width:35%;
	}

	.field_el {
		width:65%;
	}

	@media (max-width: 1040px) {
		.field_el {
			width:94%;
			margin-left:3%;
			margin-right:3%;
		}
	}

	#contact_box {
		background: -webkit-linear-gradient(to right, rgba(252, 252, 240, 1.0), #FEFEFE));
		background: linear-gradient(to right, rgba(252, 252, 240, 1.0), #FEFEFE );
	}

	.textarea_field_el {
		width: 94%;
		margin:3%;
	}

	.error-message {
		visibility:hidden;
		width:75%;
		font-weight:bolder;
		color:red;
		background-color:white;
		border: solid 1px orange;
		padding:2px;
		margin:3px;
	}

	/* The Modal (background) */
	.modal {
		display: none; /* Hidden by default */
		position: relative; /* Stay in place */
		z-index: 1; /* Sit on top */
		left: 0;
		top: 0;
		width: 100%; /* Full width */
		height: 100%; /* Full height */
		overflow: auto; /* Enable scroll if needed */
		background-color: rgb(0,0,0); /* Fallback color */
		background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
		-webkit-animation-name: fadeIn; /* Fade in the background */
		-webkit-animation-duration: 0.4s;
		animation-name: fadeIn;
		animation-duration: 0.4s
	}

	/* Modal Content */
	.modal-content {
		position: inherit;
		top: 0;
		background-color: #fefefe;
		width: 100%;
		-webkit-animation-name: slideIn;
		-webkit-animation-duration: 0.4s;
		animation-name: slideIn;
		animation-duration: 0.4s
	}

	/* The Close Button */
	.close {
		color: white;
		float: right;
		font-size: 18px;
		font-weight: bold;
	}

	.close:hover,
	.close:focus {
		color: #000;
		text-decoration: none;
		cursor: pointer;
	}

	.modal-header {
		padding: 2px 16px;
		background-color: #4ca85c;
		color: white;
	}

	.modal-body {padding: 2px 16px;}

	.modal-footer {
		padding: 2px 16px;
		margin-bottom: 20px;
		background-color: darkgreen;
		color: white;
	}

	/* Add Animation */
	@-webkit-keyframes slideIn {
		from {bottom: -300px; opacity: 0}
		to {bottom: 0; opacity: 1}
	}

	@keyframes slideIn {
		from {bottom: -300px; opacity: 0}
		to {top: 0; opacity: 1}
	}

	@-webkit-keyframes fadeIn {
		from {opacity: 0}
		to {opacity: 1}
	}

	@keyframes fadeIn {
		from {opacity: 0}
		to {opacity: 1}
	}

	#logout-control-top {
		visibility: hidden;
		display: none;
	}

</style>
</head>
<script>
	var g_siteURL = window.location.host;
	var g_finalizers = []
	var g_loginStateViewHolders = {}
</script>
<body>
	<nav id="mainNav">
		<table style="width:100%">
			<tr>
				<td style="width:62;height:63">
					<a class="nav-link" href="/">
												    <svg version="1.0" width="60" height="60" viewBox="0 0 250 250" preserveAspectRatio="xMidYMid meet" id="logo" >
								<defs id="defs10"/>
								<path class="PhIOtjDr_0"  id="path6" d="m 30.107062,7.4672872 c 4.67725,2.6985208 8.37554,8.6930958 12.94402,20.5087688 7.17904,19.072767 24.58277,67.337762 29.69511,82.950634 l 5.32989,15.9502 -13.70543,-0.25058 -10.468161,2.57106 -8.132079,2.99946 -4.78602,5.90784 0.76141,-6.91979 c 0.65264,-6.50536 0.32632,-7.85462 -5.43866,-25.31791 C 27.822822,80.549048 20.535012,60.127019 12.703332,40.215781 5.4155222,21.730904 4.4365622,15.57249 7.8085322,10.503124 11.941922,4.43145 22.384152,2.9954505 30.107062,7.4672872 Z M 238.08162,22.742849 c 3.69828,2.110631 6.52639,6.669206 6.52639,10.379672 0,1.686578 -2.93688,12.740881 -6.63517,24.469814 -19.68797,64.138095 -30.34775,107.931245 -30.34775,124.806655 0,4.6453 -1.08775,7.68113 -18.60024,50.80931 l -4.35093,10.79409 -67.76577,0 -67.765758,0 -14.35808,-35.35063 -14.35808,-35.3603 17.62128,-20.75934 17.5125,-20.75935 29.36879,0 c 32.631998,0 5.455822,5.28877 29.390108,7.16797 -3.81133,6.98972 7.16732,11.29772 7.16732,11.29772 l 2.51778,3.43975 c -1.74038,3.20932 -4.92039,6.69891 -9.3801,9.5709 l -3.2632,2.11064 -9.78959,-2.62144 c -8.593088,-2.27446 -11.312428,-2.61179 -22.080978,-2.61179 -13.0528,-0.0964 -14.35808,0.2506 -14.35808,4.29837 0,2.70817 3.15443,3.63336 12.72648,3.63336 21.42834,0 38.723308,8.01847 47.533928,22.10863 3.58951,5.73436 7.17904,15.86345 7.17904,20.50876 0,2.86236 4.45971,5.05973 7.50536,3.79721 2.82811,-1.09868 2.93687,-4.64531 0.65264,-14.01306 -2.28424,-9.36772 -7.83169,-17.88734 -15.77214,-24.29632 -5.32988,-4.30799 -6.30884,-5.49342 -5.11233,-6.24517 1.19649,-0.76135 2.06669,-0.51077 4.0246,1.08906 6.30885,5.23321 19.03534,7.00654 27.73719,3.88395 5.87377,-2.11064 11.85631,-7.17036 15.11951,-12.74088 1.52281,-2.53468 5.98253,-16.03694 9.89835,-29.9536 10.98611,-38.396111 22.08098,-72.320389 30.13021,-92.665317 5.54744,-14.176879 12.40016,-19.737762 23.16871,-18.812555 2.93688,0.250577 6.63517,1.175785 8.15801,2.023891 z m -126.72091,50.03831 c 2.28424,0.510792 5.76499,2.11063 7.72291,3.633367 5.87375,4.558576 6.20008,7.257098 3.80705,29.278954 -1.1965,10.71701 -1.94404,26.93071 -2.27035,27.1042 -0.32632,0.25057 -8.38942,-6.50868 -17.41761,-6.25812 l -16.533538,0.42407 0.65264,-6.66922 c 0.32632,-3.62372 1.19651,-13.83956 1.84915,-22.619385 0.65264,-9.19425 1.74037,-17.125977 2.50179,-18.561977 3.2632,-5.907835 10.550998,-8.269041 19.687958,-6.331889 z m 48.5129,9.454465 c 2.06668,1.011946 4.56848,3.209314 5.54744,4.89589 1.84914,2.871998 1.84914,4.22126 -0.8702,33.750816 -1.52282,17.04886 -3.37196,32.575 -4.24216,35.02295 -3.15442,8.51961 -9.13695,13.07819 -18.16513,13.67573 -4.78601,0.25056 -6.41762,0 -9.46327,-1.69622 -5.87376,-3.12256 -6.41764,-4.29838 -2.93689,-7.42094 6.20008,-5.744 4.00097,-11.09854 1.92352,-15.89687 0,0 -0.33391,-1.79223 -2.65798,-4.24016 l -2.01123,-1.92782 3.94219,-26.79768 c 1.95792,-22.869967 2.17547,-23.795174 5.11237,-26.667174 4.89478,-4.89589 16.96861,-6.24515 23.82134,-2.698522 z" />
								<rect style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:4.80000019;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4169" width="68.005806" height="55.413109" x="62.964886" y="157.3824"/>
								<rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1.60000002;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4170" width="39.957146" height="46.691494" x="105.05587" y="172.33051"/>
								<rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4172" width="134.35677" height="7.9790406" x="49.16119" y="238.93228"/>
								<text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:184.28874207px;line-height:125%;font-family:'Arial Rounded MT Bold';-inkscape-font-specification:'Arial Rounded MT Bold, Normal';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#0000ff;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="6.6644416" y="260.41125" id="text4161" transform="scale(1.041834,0.95984582)"><tspan id="tspan4163" x="6.6644416" y="260.41125">C</tspan></text>
								<text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:28.53204727px;line-height:125%;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="90" y="175.07523" id="text4165" transform="scale(0.90874022,1.1004245)"><tspan id="tspan4167" x="90" y="175.07523">opious</tspan></text>
							</svg>

					</a>
				</td>
				<td>
					copious.training : Timeline Planner
				</td>
				<td>
					&nbsp;
				</td>
			</tr>
		</table>
	</nav>
	<main id='app-main'>
	
	</main>

	<footer>
		<ul class="footer-list">
			<li>
				<a href="http://www.copious.world">copyright &copy; 2022 copious.world</a>
			</li>
		</ul>
	</footer>


</body>
</html>
<script>


// MODULE: GLOBAL CRYPTO (windowized)

//$>>	setup_window_crypto
function setup_window_crypto() {
  if ( window.g_crypto === undefined ) {
    window.g_crypto = window.crypto ? window.crypto.subtle : null
    if ( g_crypto === null  ) {
      alert("No cryptography support in this browser. To claim ownership of assets, please use another browser.")
    }
  }
}

// MODULE: base64 (windowized)
/*
MIT License

Copyright (c) 2020 Egor Nepomnyaschih

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

//$>>	getBase64Code
/*
// This constant can also be computed with the following algorithm:
const base64abc = [],
	A = "A".charCodeAt(0),
	a = "a".charCodeAt(0),
	n = "0".charCodeAt(0);
for (let i = 0; i < 26; ++i) {
	base64abc.push(String.fromCharCode(A + i));
}
for (let i = 0; i < 26; ++i) {
	base64abc.push(String.fromCharCode(a + i));
}
for (let i = 0; i < 10; ++i) {
	base64abc.push(String.fromCharCode(n + i));
}
base64abc.push("+");
base64abc.push("/");
*/
const base64abc = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"
];

const base64abc_url = [
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
	"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "_"
]

/*
// This constant can also be computed with the following algorithm:
const l = 256, base64codes = new Uint8Array(l);
for (let i = 0; i < l; ++i) {
	base64codes[i] = 255; // invalid character
}
base64abc.forEach((char, index) => {
	base64codes[char.charCodeAt(0)] = index;
});
base64codes["=".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error
*/
const base64codes = [
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255,
	255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255,
	255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
];

const url_alternates = "-_"
const plus_alt = url_alternates.charCodeAt(0)
const slash_alt = url_alternates.charCodeAt(1)

function getBase64Code(charCode) {
	if ( plus_alt === charCode ) {
		return 62
	}
	if ( slash_alt === charCode ) {
		return 63
	}
	if (charCode >= base64codes.length) {
		throw new Error("Unable to parse base64 string.");
	}
	const code = base64codes[charCode];
	if (code === 255) {
		throw new Error("Unable to parse base64 string.");
	}
	return code;
}

//$>>	bytesToBase64
function bytesToBase64(bytes,url_no) {
	let apha = url_no ? base64abc : base64abc_url
	let result = '', i, l = bytes.length;
	for (i = 2; i < l; i += 3) {
		result += apha[bytes[i - 2] >> 2];
		result += apha[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += apha[((bytes[i - 1] & 0x0F) << 2) | (bytes[i] >> 6)];
		result += apha[bytes[i] & 0x3F];
	}
	if (i === l + 1) { // 1 octet yet to write
		result += apha[bytes[i - 2] >> 2];
		result += apha[(bytes[i - 2] & 0x03) << 4];
		result += "==";
	}
	if (i === l) { // 2 octets yet to write
		result += apha[bytes[i - 2] >> 2];
		result += apha[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
		result += apha[(bytes[i - 1] & 0x0F) << 2];
		result += "=";
	}
	return result;
}

//$>>	base64ToBytes
function base64ToBytes(str) {
	if (str.length % 4 !== 0) {
		throw new Error("Unable to parse base64 string.");
	}
	const index = str.indexOf("=");
	if (index !== -1 && index < str.length - 2) {
		throw new Error("Unable to parse base64 string.");
	}
	let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0,
		n = str.length,
		result = new Uint8Array(3 * (n / 4)),
		buffer;
	for (let i = 0, j = 0; i < n; i += 4, j += 3) {
		buffer =
			getBase64Code(str.charCodeAt(i)) << 18 |
			getBase64Code(str.charCodeAt(i + 1)) << 12 |
			getBase64Code(str.charCodeAt(i + 2)) << 6 |
			getBase64Code(str.charCodeAt(i + 3));
		result[j] = buffer >> 16;
		result[j + 1] = (buffer >> 8) & 0xFF;
		result[j + 2] = buffer & 0xFF;
	}
	return result.subarray(0, result.length - missingOctets);
}


//$>>	base64encode
function base64encode(str, encoder = new TextEncoder()) {
	return bytesToBase64(encoder.encode(str));
}

//$>>	base64decode
function base64decode(str, decoder = new TextDecoder()) {
	return decoder.decode(base64ToBytes(str));
}



//$$EXPORTABLE::
/*
getBase64Code
bytesToBase64
base64ToBytes
base64encode
base64decode
*/

//$$EXPORTABLE::
/*
setup_window_crypto
*/

// MODULE: CRYPTO HASH (windowized)

// >> import
//modularize>> import * as base64 from "../modules/base64.js";
//<<
	base64 = window

//$>>	do_hash_buffer
async function do_hash_buffer(text) {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hash = await g_crypto.digest('SHA-256', data);
    return hash
}

//$>>	do_hash
async function do_hash(text) {
    let buffer = await do_hash_buffer(text)
    const hashArray = Array.from(new Uint8Array(buffer));
    return base64.bytesToBase64(hashArray)
}

//$>>	from_hash
function from_hash(base64text) {
    let bytes = base64.base64ToBytes(base64text)
    return bytes
}

//$>>	to_base64
function to_base64(text) {
    return base64.base64encode(text)
}

//$>>	from_base64
function from_base64(base64text) {
    let bytesAsText = base64.base64decode(base64text)
    return bytesAsText
}

//$>>	from_base64_to_uint8array
function from_base64_to_uint8array(base64text) {
    while ( base64text.length %4 ) base64text += '='
    return base64.base64ToBytes(base64text)
}

//$>>	to_base64_from_uint8array
function to_base64_from_uint8array(a_uint8Array) {
    let b = base64.bytesToBase64(a_uint8Array)
    b = b.replace(/\=/g,'')
    return b
}

//$$EXPORTABLE::
/*
do_hash_buffer
do_hash
from_hash
to_base64
from_base64
from_base64_to_uint8array
to_base64_from_uint8array
*/




	async function postData(url = '', data = {}, creds = 'omit', do_stringify = true) {
		// Default options are marked with *
		const response = await fetch(url, {
			method: 'POST', // *GET, POST, PUT, DELETE, etc.
			mode: 'cors', // no-cors, *cors, same-origin
			cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
			credentials: creds, // include, *same-origin, omit
			headers: {
				'Content-Type': 'application/json'
			},
			redirect: 'follow', // manual, *follow, error
			referrerPolicy: 'no-referrer', // no-referrer, *client
			body: (do_stringify ? JSON.stringify(data)  : data)	// body data type must match "Content-Type" header
		});
		if ( response.ok == false ) {
			console.log(response.status + ': ' + response.statusText)
		}
		return await response.json(); // parses JSON response into native JavaScript objects
	}

	async function post_submit(fields) {
		let bdy = {}
		fields.forEach(element => {
			let fld = document.getElementById(element)
			if ( fld ) {
				bdy[element] = fld.value
			}
		});
		let url = bdy.post_url
		if ( url ) {
			delete bdy.post_url
			//
			let resp = await postData(url, bdy)
			//
			if ( resp ) hide_interface_box()
			if ( resp && (resp.OK === 'true') ) {
				show_box('success-box')
			} else {
				show_box('error-box')
			}
		}
	}


	let admin_ucwid = "this-is-a-test"



// MODULE: ONE TABLE(windowized)

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

//>>  AppDBWrapper


// In the following line, you should include the prefixes of implementations you want to test.
window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
// DON'T use "var indexedDB = ..." if you're not in a function.
// Moreover, you may need references to some window.IDB* objects:
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
// (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)


/*

// autoIncrement set to true  (for this special case DB use )

DB_VERSION
DATA_STORE
describe_data

*/


function warn(str) {
    //
}


// a session is a project...
// a session object (sessionObject) is stored in the DB and may contain parts of data
// part_id identifies a part of the data (e.g. a layer or a component)

class AppDBWrapper {

    constructor(name,conf) {
        this._can_process_db = true
        if ( !(window.indexedDB) ) {
            this._can_process_db = false
            console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
        }
        //
        let self = this
        // DATA_STORE
        // DB_VERSION
        // describe_data
        if ( conf ) {
            for ( let ky in conf ) {
                self[ky] = conf[ky]
            }    
        }
        //
        this.db = false
        this.current_session_name = 'none'
        this._session_name_list = []
        this.name = name
        //
    }


    set session_name(name) {
        this.current_session_name = name
    }

    get session_name() {
        return this.current_session_name
    }

    get name_list() {
        return this._session_name_list
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    init_database() {
        //
        if ( !(this._can_process_db) ) return false
        let self = this
        let db_name = this.name
        //
        let p = new Promise((resolve,reject) => {

            let request = window.indexedDB.open(db_name, this.DB_VERSION);
            //
            // <-- onerror
            request.onerror = (event) => {
                alert(`This web app will not store ${this.describe_data} without the use of computer storage.`)
            };
            
            // <-- onsuccess
            request.onsuccess = (event) => {
                //
                let db = event.target.result;
                db.onerror = (event) => {
                    console.log("Database error: " + event.target.error);
                    reject(event.target.error)
                };
                //
                self.db = db;
                resolve(db)
            }

            // <-- onupgradeneeded
            request.onupgradeneeded = (event) => {
                //
                let db = event.target.result;
                //
                try {
                    let sessionObjectStore = db.createObjectStore(this.DATA_STORE, { autoIncrement : true });
                    sessionObjectStore.createIndex("name", "name", { unique: true });
                    sessionObjectStore.createIndex("sess_date_time", "sess_date_time", { unique: true });
                } catch (e) {
                }
            //
            };
        })  // end of promise
        //
        return p
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //      load_name_list
    // -- 
    load_name_list() {
        if ( !(this.db) ) return
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readonly");
        let dataStore = transaction ? transaction.objectStore(this.DATA_STORE) : false
        //
        if ( !(dataStore) ) return false
        let p = new Promise((resolve,reject) => {
            this._session_name_list = []
            let myIndex = dataStore.index('name');
            myIndex.openCursor().onsuccess = (event) => {
                let cursor = event.target.result;
                if ( cursor ) {
                    this._session_name_list.push(cursor.value.name)
                    this.application_total_entry(cursor.value)
                    cursor.continue();
                } else {
                    this.application_update_session_name_selections(this.current_session_name,this._session_name_list)
                    resolve(true)
                }
            }
        })
        //
        return p
    }

    // _apply_find_by_name
    //  -- a generic that calls success_callback when an element matches the index, or not_found_callback otherwise.
    //
    _apply_find_by_name(sess_name, store, success_callback, not_found_callback) {
        let nameIndex = store.index('name');
        nameIndex.get(sess_name).onsuccess = (evt) => {
            let value = evt.target.result;
            if ( value ) {
                if ( success_callback ) success_callback(value,nameIndex);
            } else {
                if ( not_found_callback ) not_found_callback();
            }
        };
    }

    // _add_session_to_db
    //  -- adds the session object to the db, sets up the basic fields... 
    //
    _add_session_to_db(dataStore,application_op,part_id) {
        //
        let sessionObj = {
            'name' : this.current_session_name,
            'sess_date_time' : '' + Date.now(),
            'data' : { },
            'hashes' : { },
            'edit_order' : []
        }
        //
        if ( part_id ) sessionObj.edit_order.push(part_id)
        //
        if ( (application_op !== undefined) && (typeof application_op === 'function') ) {
            application_op(sessionObj)
        }
        let request = dataStore.add(sessionObj);
        return request
    }
  

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    // add_data -- 
    //  Parameters: blob_data -- data stored as part of the session
    //              session id could be a layer....
    add_data(blob_data,part_id) {
        if ( !(this._can_process_db) ) return false
        if ( !(this.db) ) {
          console.log(`db not initialized :: AppDBWrapper.add_data`)
          return;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        let p = new Promise((resolve,reject) => {
            let self = this
            // update_list_callback
            let update_list_callback = (value,dbIndex) => {     // if found update
                if ( !dbIndex || (typeof value === "undefined") ) {
                    resolve(false)
                    return;
                }
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        // existing session 
                        let sessionObj = cursor.value
                        //
                        let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                        // map_id = part_id
                        // store revised data
                        sessionObj.data[part_id] = blob_data
                        // make sure the structure has been set up if not already
                        if ( sessionObj.hashes[part_id] === undefined ) {
                            sessionObj.hashes[part_id] = {}
                        }
                        if ( sessionObj.hashes[part_id].op_history === undefined ) {
                            sessionObj.hashes[part_id].op_history = []
                        }
                        // record the order in which sessions (layers) have been edited
                        sessionObj.edit_order.push(part_id)
                        //
                        // update IndexedDB
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            try {
                                self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                            } catch (e) {
                                console.log(e)
                            } finally {
                                resolve(true)
                            }
                        };

                        request.onerror = (event) => {
                            resolve(false)
                        }
                        //
                    } else {
                        resolve(false)
                    }
                }
            }
            // add_new_callback
            let add_new_callback = () => {          // if not found add a new one
                //
                let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                //
                let application_op = (sessionObj) => {
                    //
                    sessionObj.data[part_id] = blob_data
                    if ( sessionObj.hashes[part_id] === undefined ) {
                        sessionObj.hashes[part_id] = {}
                    }
                    sessionObj.hashes[part_id].op_history = []
                    //
                } 
                //
                let request = self._add_session_to_db(dataStore,application_op,part_id)
                if ( request ) {
                    request.onsuccess = (event) => {
                        self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                        resolve(true)
                    };
                    request.onerror = (event) => {
                        resolve(false)
                    }
                }
                //
            }
            //
            this._apply_find_by_name(this.current_session_name, dataStore, update_list_callback, add_new_callback)    
        })
        //
        return p
    }


    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    remove_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let remove_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        delete sessionObj.data[part_id]
                        //
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            //  item has been removed
                            console.log(`deleted ${part_id}`)
                            await this.app_secure_total_session(sess_name)
                            resolve(true)
                        };
                        //
                        request.onerror = (e) => {
                            resolve(false)
                        }
                    }
                    resolve(false)
                }
            }

            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }

            this._apply_find_by_name(sess_name, dataStore, remove_from_list_callback, not_found_callback)
        })

        return p
    }
      
    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    get_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let get_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        let value =  sessionObj.data[part_id]
                        if ( value === undefined ) {
                            resolve(false)
                        } else {
                            resolve(value)
                        }
                    }
                    resolve(false)
                }
            }
        
            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }
        
            this._apply_find_by_name(sess_name, dataStore, get_from_list_callback, not_found_callback)
        })

        return p
    }
      
 
    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //  get_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //  Returns the object controlling all the data within the session.
    get_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: get_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
          //
          // get_elem_callback
          let get_elem_callback = (value,dbIndex) => {          // element.name == sess_name exists
            //
            let keyRangeValue = IDBKeyRange.only(value.name);
            //
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
              let cursor = event.target.result;
              if ( cursor ) {
                let sessionObj = cursor.value
                resolve(sessionObj)
              } else {
                reject(null)
              }
            }
          }
          //
          // not_found_callback
          let not_found_callback = () => {                       // element.name == sess_name  NOT FOUND
            reject(null)
          }
          //
          this._apply_find_by_name(sess_name, dataStore, get_elem_callback, not_found_callback)
        })
        //
        return p
    }

     
    //  delete_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //
    delete_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false

        if ( sess_name !== 'none ') {
            if ( this.db === null ) {
                console.log("db not initialized :: delete_session")
                return false;
            }
            //
            let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
            if ( !(transaction) ) return false
            let dataStore = transaction.objectStore(this.DATA_STORE);
            if ( !(dataStore) ) return false
        
            let p = new Promise((resolve,reject) => {
                // delete_from_list_callback
                let delete_from_list_callback = (value,dbIndex) => {
                    //
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    //
                    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            let request = cursor.delete();
                            request.onsuccess = async () => {
                                this.current_session_name = 'none'   /// here last
                                await this.load_name_list()
                                this.application_revise_current_session(this.current_session_name)
                                resolve(true)
                            };
                        }
                        resolve(false)
                    }
                }
                //
                let not_found_callback = () => {
                    warn(`The session ${sess_name} is not in the database`)
                    resolve(false)
                }
                //
                this._apply_find_by_name(sess_name, dataStore, delete_from_list_callback, not_found_callback)    
            })
            //
            return p
        }
        return false
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {

    }

    application_total_entry(sess_obj) {
        
    }

}




//$$EXPORTABLE::
/*
AppDBWrapper
*/


class TimeLineDB extends AppDBWrapper {
	//
	constructor(conf) {
		super("human-timeslot-records",conf)
		this.current_session_name = conf.time_slot_sessions
		this.current_time_slot_name = ""
		this.current_description = ""
		this.current_file_list = []
		//
		this.current_time_slot = false
		this.current_time_slot_data = false
		//
		this.clear_identity_list_data()
	}

	async add_time_slot(time_slot_object) {
		let part_id = time_slot_object.name
		let blob_data = time_slot_object
		blob_data = JSON.stringify(blob_data)
		return await this.add_data(blob_data,part_id)
	}

	async update_time_slot(time_slot_object) {  // db will update the found object or add it new
		await this.add_time_slot(time_slot_object)
	}

	async get_time_slot(a_time_slot_name) {
		try {
			let time_slot_Obj_str = await this.get_data(a_time_slot_name,this.current_session_name)
			let time_slot_Obj = JSON.parse(time_slot_Obj_str)
			if ( time_slot_Obj ) {
				//
				this.current_time_slot = time_slot_Obj
				//
				this.current_time_slot_name = time_slot_Obj.name
				//
				return time_slot_Obj
			}
		} catch (e) {
			console.log("get_time_slot")
		}
		return false
	}



	//
	async remove_time_slot() {
		return await this.remove_data(this.current_time_slot_name,this.current_session_name)
	}

	// 
	async get_time_slot_names() {
		let sess_name = this.current_session_name
		try {
			let sess_data = await this.get_session(sess_name)
			if ( sess_data ) {
				let f_names = Object.keys(sess_data.data)
				return f_names
			}    
		} catch (e) {
			console.log("get_file_names")
		}
		return []
	}

	async get_slot_entries() {
		let sess_name = this.current_session_name
		try {
			let sess_data = await this.get_session(sess_name)
			if ( sess_data ) {
				let t_slots = []
				for ( let ky in sess_data.data ) {
					let f_data = sess_data.data[ky]
					t_slots.push(JSON.parse(f_data))
				}
				return t_slots
			}
		} catch (e) {
			console.log("get_file_entries")
		}
		return []    
	}

	// // // // // // // // // // // // // // // // // // // // // // // // // // // // 

	app_add_fields(sessionObj) {
		//sessionObj.project_name = this.current_time_slot_name
		//sessionObj.author = this.current_author
		//sessionObj.description = this.current_description
	}

	application_data_update(blob_url,part_id,blob_data) {
		// implemented by derived method (override)
	}

	async app_secure_total_session(sess_name) {
		// implemented by derived method (override)
	}

	application_revise_current_session(sess_name) {
		// implemented by derived method (override)
	}

	application_update_session_name_selections(sess_name,name_list) {}

	clear_identity_list_data() {
		this.identity_list = []
		this.time_line_list = []
	}

	application_total_entry(session_object) {
		///this.identity_list.push(identity)
		this.time_line_list.push(session_object.data)
	}

	async get_known_time_lines() {
		this.clear_identity_list_data()
		await g_human_time_slot_storage.load_name_list()
		return [this.time_line_list,this.identity_list]
	}

}



//$>>	db_startup

const DB_VERSION = 1
const DATA_STORE = "timeslot-projects"
const describe_data = "time slot records"
const candidate_session_name = "copious-training-sessions"

let g_human_time_slot_storage = false
let g_human_time_slot_storage_ref = [false]

async function db_startup() {
    //
    g_human_time_slot_storage = new TimeLineDB({
        "DB_VERSION" : DB_VERSION,
        "DATA_STORE" : DATA_STORE,
        "describe_data" : describe_data,
		"time_slot_sessions" : candidate_session_name
    })

    await g_human_time_slot_storage.init_database()
    await g_human_time_slot_storage.load_name_list()

    g_human_time_slot_storage_ref[0] = g_human_time_slot_storage
    
    return g_human_time_slot_storage
}



// /////////////////////////////////////////////////////




// SHARED CONSTANTS


// SITE PAGE
//
const SITE_PAGE_TO_FRAME = "site_page_to_frame"
const SITE_PAGE_TO_BUILDER = "site_page_to_builder"
const SITE_PAGE_TO_ALL = "RELAY"
const SITE_RELATES_TO_BUILDER = "site_page_request_id"
const SITE_RELATES_TO_FRAME = "site_page_request_action"
const SITE_RELATES_TO_ALL = "site_frame_yields_news"

// FRAME PAGE
const FRAME_PAGE_TO_HOSTED_APP = "frame_page_to_hosted_app"
const FRAME_PAGE_TO_SITE = "frame_page_to_site"
const FRAME_PAGE_TO_BUILDER = "frame_page_to_builder"
const FRAME_PAGE_TO_SERVICE_WORKER = "frame_page_to_sw"
const FRAME_PAGE_TO_WORKER = "frame_page_to_w"
const FRAME_PAGE_RELATES_TO_SITE = "frame_page_injector"
const FRAME_PAGE_RELATES_TO_BUILDER = "frame_page_reponses"
const FRAME_PAGE_RELATES_TO_SERVICE_WORKER = "frame_page_shared_action"
const FRAME_ACTION_TO_APP = "frame_page_request_action"
const FRAME_REQUEST_SESSION = "frame_page_request_session"
const FRAME_ACTION_FROM_APP = "hosted_app_requests_action"

// APP PAGE
//
const HOSTED_APP_TO_FRAME = "hosted_app_to_frame"
const HOSTED_APP_TO_ALL = "RELAY"
const APP_RELATES_TO_FRAME = "app_in_human_context"
const APP_RELATES_TO_ALL = "app_in_frame_yields_news"

// BUILDER PAGE
//
const BUILDER_PAGE_TO_FRAME = "builder_page_to_frame"
const BUILDER_PAGE_TO_SITE = "builder_page_to_site"
const BUILDER_RELATES_TO_SITE = "builder_page_injector"
const BUILDER_ACTION_TO_FRAME = "builder_page_request_action"

// HUMAN FRAME WORKER
const WORKER_TO_FRAME = "worker_to_frame"
const WORKER_RELATES_TO_FRAME = "worker_request_action"


//
// actions
const FRAME_COMPONENT_RESPOND = "respond"
const FRAME_COMPONENT_RESPONDING = "responding"
const FRAME_ACTION_LOAD_APP = "load-app"
const FRAME_ACTION_INSTALL = "install-id"
const FRAME_ACTION_INJECT = "inject"
const FRAME_START_SESSION = "start-session"
const FRAME_HAS_SESSION = "has-session"
const FRAME_NEEDS_SIGNATURE = "get-signature"
const FRAME_WANTS_SESSION = "get-session"
const FRAME_STOP_SESSION = "stop-session"
const FRAME_HAS_PERSONALIZATION = "has-personalization"
const SITE_WANTS_SIGNATURE = "send-sig-remote"
const HOST_UP_REQ_UPLOAD = "send-request-upload"


const MANAGER_PAGE_TO_FRAME = "from-manager-to-frame"
const ID_MANAGER_ACTION_TO_FRAME = "id-presence-manager"
const FRAME_ACTION_REMOVE = "id-manager-remove-id"
const FRAME_ACTION_UPLOAD = "id-manager-upload-id"
const FRAME_ACTION_DOWNLOAD = "id-manager-download-id"
const FRAME_ACTION_DOWNLOAD_PUBLIC = "id-manager-download-public-intro"
const FRAME_MANAGE_PICTURE_ASSET = "manager-picture-asset"
const FRAME_ACTION_ATTACH = "manager-asset-attach"


const HOST_APP_WANTS_SESSION = "session-to-app"


// categories
const FRAME_COMPONENT_SAY_ALIVE = "q-alive"
const FRAME_COMPONENT_MANAGE_ID = "m-igid"
const HOST_APP_PERSONALIZATION = "personalization"
const FRAME_TO_APP_PUBLIC_COMPONENT = "process-public-info"
const SITE_TO_FRAME_SESSIONS = "transfer-session"
const FRAME_TO_SITE_MANAGE_SESSION = "site-manage-session"
const WORKER_TO_FRAME_SESSIONS = "w-transfer-session"
const FRAME_WORKER_TO_SESSIONS = "transfer-session"
const FRAME_TO_HOSTED_APP_SESSIONS = "transfer-session"
const FRAME_TO_APP_SIGNATURE = "signed-data"
const FRAME_SIGNED = "yep-signed"
const FRAME_POSTED_PRIMARY = "yep-primary-response"


//
let g_user_current_session = false
let g_current_user_id = false
let g_current_user_name = false
let g_current_pub_identity = false


const g_message_template =  {
                                "category" : "",
                                "direction" : "",
                                "action" : "",
                                "relationship" : ""
                            }


/// END OF CONSTANTS


// HOSTED APP PAGE COM
//
if ( typeof g_message_template === undefined ) {
    window.g_message_template = g_message_template = {
        "category" : "",
        "direction" : "",
        "action" : "",
        "relationship" : ""
    }
}

// constants in shared constants

let g_frame_page = window.parent

let hosted_page_application_handlers = (category,action,relationship,params) => {}



function reponding_alive() {
    let message = {
        "category": FRAME_COMPONENT_SAY_ALIVE,
        "action" : FRAME_COMPONENT_RESPONDING,
        "data" : false
    }
    tell_frame_page(message)
}


function install_frame_page_response() {
    window.addEventListener("message", (event) => {
        let page_source = event.origin
        if ( page_source !== '*' ) {
            // let opener = event.source --- the site page is assumed to be the top level of the interactions
            try {
                let mobj = JSON.parse(event.data)
                let category = mobj.category
                let relationship = mobj.relationship
                let action = mobj.action
                let direction = mobj.direction
                //
                if ( direction === FRAME_PAGE_TO_HOSTED_APP ) {
                    if ( category === FRAME_COMPONENT_SAY_ALIVE ) {
                        if ( action === FRAME_COMPONENT_RESPOND ) {
                            reponding_alive()
                        }
                    } else {
                        let params = mobj.data
                        hosted_page_application_handlers(category,action,relationship,params)
                    }
                }
            } catch (e) {
            }    
        }
    })
}


let injest_personalization = false
let injest_session = false
let application_specific_handlers = (category,action,relationship,params) => {}

let personalization = (post_params) => {}


hosted_page_application_handlers = async (category,action,relationship,params) => {
    switch ( category ) {
        case HOST_APP_PERSONALIZATION : {
            if ( typeof injest_personalization === "function" ) {
                await injest_personalization(action,params)
            }
            break;
        }
        case FRAME_TO_HOSTED_APP_SESSIONS : {          /// a hosted page that does not start a session.
            if ( typeof injest_session === "function" ) {
                await injest_session(action,params)
            }
            break;
        }
        default: {                  /// any other actions ... could be a login page that fetches a session
            await application_specific_handlers(category,action,relationship,params)
            break;
        }
    }
}




function tell_frame_page(message) {
    if ( !g_frame_page ) return(false)
    let msg = Object.assign({},g_message_template)
    msg.direction = HOSTED_APP_TO_FRAME
    msg.relationship = APP_RELATES_TO_FRAME
    msg.action = message.action
    msg.category = message.category
    msg.data = message.data
    let message_str = JSON.stringify(msg)
    g_frame_page.postMessage(message_str,'*')
    return true
}

function relay_to_pages(message) {
    if ( !g_frame_page ) return(false)
    let msg = Object.assign({},g_message_template)
    msg.direction = HOSTED_APP_TO_ALL
    msg.relationship = APP_RELATES_TO_ALL
    msg.action = message.action
    msg.category = message.category
    msg.data = message.data
    let message_str = JSON.stringify(msg)
    g_frame_page.postMessage(message_str,'*')
}



// END OF HOSTED APP PAGE COM  (ALPHA)



///   APPLICATION CODE -- -- -- -- -- -- -- 

function hide_interface_box() {
	let display = document.getElementById('interface-box')
	if ( display ) {
		display.style.visibility = "hidden"
		display.style.display = "none"
	}
}

function hide_box(bxname) {
	let display = document.getElementById(bxname)
	if ( display ) {
		display.style.visibility = "hidden"
		display.style.display = "none"
	}
}

function show_box(bxname) {
	let display = document.getElementById(bxname)
	if ( display ) {
		display.style.visibility = "visible"
		display.style.display = "block"
	}
}

hide_box('error-box')
hide_box('success-box')



retrieve_session = () =>  {
	let message = {
		"category": FRAME_ACTION_FROM_APP,
		"action" : HOST_APP_WANTS_SESSION,
		"data" : false
	}
	tell_frame_page(message)
}



retrieve_personalization = () =>  {
	let message = {
		"category": FRAME_ACTION_FROM_APP,
		"action" : HOST_APP_PERSONALIZATION,
		"data" : false
	}
	tell_frame_page(message)
}



// ---- ---- ---- ---- ---- ----
injest_personalization = (action,params) => {

	let preferences = params.personalization
	let public_id = params.puplic_info

}

// ---- ---- ---- ---- ---- ----
injest_session = (action,params) => {

	let session = params.session

}


/*
let post_params = {
	"uid" : uid,
	"query" : qry,
	"box_count" : l,
	"offset" : stindex
};
*/

personalization = (post_params) => {    // APPLICATION CODE
	// look for ucwid, session, etc.
	// alter the post_params to queue the search engine what to get...
	//

	//
}






// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

let g_responder_tables = {
    "post-response" : {
        "resolver" : false,
        "rejector" : false
    }
}

function promise_handling(source_name) {
    if ( g_responder_tables[source_name] !== undefined ) {  // do we implement this entry?
        let p = new Promise((resolve,reject) => {
            g_responder_tables[source_name].resolver = (resp_obj) => {
                g_responder_tables[source_name] = {
                    "resolver" : false,
                    "rejector" : false            
                }
                resolve(resp_obj)
            }
            g_responder_tables[source_name].rejector = () => {
                g_responder_tables[source_name] = {
                    "resolver" : false,
                    "rejector" : false            
                }
                reject(false)
            }
        })
        return p    
    }
    return false
}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

	application_specific_handlers = async (category,action,relationship,params) => {
		try {
			if ( category === FRAME_TO_APP_PUBLIC_COMPONENT ) {
				switch ( action ) {
					case FRAME_POSTED_PRIMARY: {
						let response = params.response
						if ( response ) {
							g_responder_tables["post-response"].resolver(response)
						} else {
							g_responder_tables["post-response"].rejector()
						}
						break
					}
				}
			}
		} catch (e) {
			console.log(e)
		}
	}

	async function retrieve_slots() {
		return []
	}


	/*
	time_slot_meta
			link
			secondary_link
	*/

	let g_app_path = "command-upload"


	// g_app_path important to nginx configuration

	function get_transition_endpoint(endpoint) {
		let url = `${location.protocol}//${location.host}/${g_app_path}/transition/${endpoint}`
		return url
	}

	function get_secondary_transition_endpoint(endpoint) {  // uploader-commands
		let url = `${location.protocol}//${location.host}/${g_app_path}/transition/secondary/${endpoint}`
		return url
	}


	function min_start_max_end_times(time_slots) {
		let min_start = Infinity
		let max_end = 0
		for ( let ts of time_slots ) {
			//
			let start = ts.start_time
			let end = ts.end_time
			if ( start < min_start ) min_start = start
			if ( end > max_end ) max_end = end
			//
		}
		return [min_start,max_end]
	}


	async function send_time_slots(time_slots,time_slot_meta) {
		let slots_str = JSON.stringify(time_slots)
		let data_hash = do_hash(slots_str)
		let message = {
			"category": FRAME_ACTION_FROM_APP,
			"action" : HOST_UP_REQ_UPLOAD,
			"data" : {
				"link" : get_transition_endpoint(time_slot_meta.link),
				"hash" : data_hash,
				"postable" : {		// send the fields this knows about. Expect the frame to had a hash and security
					"topic" : "command-upload",
					"path" : "upload-lite"
				}    /// slots are going later....
			}
		}
		tell_frame_page(message)  // ask for the primary transition to be handled by the human frame...
		//
		let primary_response = await promise_handling("post-response")
		if ( (primary_response.OK == true) &&  (primary_response.signage) ) {
			let upload_keys = primary_response.elements  // should be produced by publication handling
			let [min_time,max_time] = min_start_max_end_times(time_slots)
			let data_descriptor = {
				"ucwid" : primary_response.ucwid,
				"start_all_time" : min_time,
				"end_all_time" : max_time,
				"time_slots" : slots_str
			}
			let postable = {
				"token" : primary_response.token,		// primary action token (key to secondary)
				"topic" : "publish",
				"asset_type" : "calendar",
				"sign" : upload_keys.sign,
				"data" : data_descriptor,
				"hash" : data_hash
			}
			let link = get_secondary_transition_endpoint(time_slot_meta.secondary_link)
			let resp = await postData(link,postable)
			if ( resp.status = "OK" ) {
				return true
			}
			return false
		}
	}


// /////////////////////////////////////////////////////


setup_window_crypto()

db_startup()


</script>

